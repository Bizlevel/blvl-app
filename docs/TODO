# 1. Анализ архитектуры и логики чата Leo AI  (04.08.2025)

## 1. Стек файлов и компонентов  
- `lib/services/leo_service.dart` — клиент-сервис, инкапсулирующий:  
  – отправку сообщений (Edge Function / прямой OpenAI API);  
  – модерацию через OpenAI /moderations;  
  – учёт лимитов, RPC `decrement_leo_message`, `reset_leo_unread`;  
  – сохранение чата и сообщений в БД (`leo_chats`, `leo_messages`).  
• Провайдеры Riverpod  
  – `leoServiceProvider.dart` (DI SupabaseClient → LeoService)  
  – `leo_unread_provider.dart` — стрим `unread_count` по чату.  
• UI  
  – `FloatingChatBubble.dart` — «пузырик» с бейджем непрочитанных; открывает `LeoDialogScreen`.  
  – `leo_chat_screen.dart` — список чатов.  
  – `leo_dialog_screen.dart` — сам диалог: пагинация, ввод, автоскролл, вызовы LeoService.  
  – вспом. виджеты `ChatItem`, `LeoMessageBubble`.  
• Серверная логика  
  – `supabase/functions/leo-chat/index.ts` — Edge Function-прокси к OpenAI.  
    Использует Service-Role key для БД, добавляет CORS-заголовки.  

## 2. Формирование контекста для Leo  
• Клиент собирает `messages` в формате Chat Completion (`role/user/assistant`, `content`).  
  – Начальный контекст – история из `leo_messages` (пагинация 30 шт.).  
  – Системного промпта со стороны клиента нет (параметр `systemPrompt` в `FloatingChatBubble` сейчас никуда не передаётся).  
• Edge Function добавляет системовое сообщение:  
```text
role: "system"
content: "Ты Leo — дружелюбный AI-ментор по бизнесу. Отвечай лаконично на русском языке. Имя пользователя: … Цель: … О себе: …"
```  
  – Персональные данные берутся из таблицы `users` (`name`, `about`, `goal`) через `supabaseAdmin.auth.getUser(jwt)` + select.  
• Если в `.env` определён `OPENAI_API_KEY`, мобильный клиент пропускает Edge Function и обращается к OpenAI напрямую (та же модель gpt-3.5-turbo, temperature 0.7).  

## 3. Формат ответа и обработка  
• Ожидается JSON вида  
```json
{
  "message": { "content": "<ответ>" },
  "usage": { "prompt_tokens":..., "completion_tokens":..., "total_tokens":... }
}
```  
• UI извлекает `message.content` и отображает plain-text; markdown/форматирование не требуют-ся.  
• После приёма ответа:  
  – LeoService сохраняет в `leo_messages` (`role='assistant'`), инкрементирует `message_count` в `leo_chats`.  
  – Счётчик непрочитанных (`unread_count`) поддерживается Postgres-триггером (не в коде клиента).  

## 4. Модель данных Supabase (public schema)  
• `leo_chats`  
  – `id uuid PK`, `user_id uuid FK users`, `title text`, `message_count int`,  
    `unread_count int`, `created_at / updated_at timestamptz`.  
• `leo_messages`  
  – `id uuid PK`, `chat_id uuid FK leo_chats`, `user_id uuid FK users`,  
    `role text`, `content text`, `token_count int`, `created_at timestamptz`.  
• Таблица `users` содержит лимиты:  
  – `leo_messages_total` (для free-тарифа; дефолт 30);  
  – `leo_messages_today`, `leo_reset_at` (дневной лимит premium);  
  – `is_premium bool`.  
• Сторонние процедуры/триггеры  
  – `decrement_leo_message()` — атомарно уменьшает счётчик и возвращает остаток.  
  – `reset_leo_unread(p_chat_id uuid)` — обнуляет `unread_count` чата.  
  – триггер на `leo_messages` ↑ `unread_count`, заполняет `token_count` (по usage).  

## 5. Поток взаимодействия  
1. Пользователь открывает `LeoDialogScreen` → загружается первая страница сообщений; LeoService `reset_unread`.  
2. Пользователь вводит сообщение →  
   а) LeoService `saveConversation(role:'user')`;  
   б) RPC `decrement_leo_message` → обновляет лимит;  
   в) `sendMessage` → (Edge Function или прямой OpenAI) → ответ;  
   г) LeoService `saveConversation(role:'assistant')`.  
3. UI рендерит новое сообщение, счётчики на экранах обновляются по real-time стримам.  

## 6. Итог:  
– Вся логика Leo сконцентрирована в Edge Function + `LeoService`.  
– Контекст включает персональные данные пользователя; связь с уроками/уровнями пока отсутствует (но параметр `systemPrompt` в `FloatingChatBubble` заложен для будущей передачи контекста урока).  
– Формат общения — стандартный Chat Completion, ответы на русском, лаконичные.  
– Supabase хранит чаты/сообщения, лимиты и статистику в `users`.  

# 2. Сейчас в коде реализованы две схемы общения с OpenAI.

## 1. Edge Function `supabase/functions/leo-chat/index.ts`  
   – Запрос приходит с Bearer-JWT пользователя, сервер сам достаёт профиль и добавляет системный prompt.  
   – Ключ `OPENAI_API_KEY` хранится **только** в переменных окружения Supabase; до клиента он не попадает.  
   – Ответ возвращается клиенту; токены/непрочитанные считаются триггерами в БД.  
   → Это безопасный, “правильный” путь.

## 2. Клиентский обход в `lib/services/leo_service.dart`  
```dart
final openaiKey = envOrDefine('OPENAI_API_KEY');
if (openaiKey.isNotEmpty) {
    // прямой запрос к https://api.openai.com
}
```
   – Если при сборке передан `--dart-define OPENAI_API_KEY=…` **или** ключ есть в `.env`, Flutter-клиент инжектирует его в бинарь и начинает обращаться в OpenAI напрямую, обходя функцию-прокси.  
   – Контекст пользователя формируется только из локальной истории сообщений, без профиля из БД.  
   – Ключ становится доступен реверс-инжинированием → нарушение безопасности.
## Фактическое поведение сейчас:  
• В mobile/web сборках, где `.env` читается, ключ присутствует → используется **прямая клиентская схема**.  
• Если ключ не передавать (prod Web через Vercel, CI без секретов) – клиент падает на Edge Function.
## Вывод  
Рабочей (целевой) должна быть **серверная (Edge Function)** логика; клиентская нужна только как “костыль” для локальной разработки, но приводит к утечке API-ключа.
## Рекомендации  
1. Удалить/закомментировать ветку с прямым вызовом OpenAI из `LeoService`:  
   – проверку `openaiKey.isNotEmpty` и последующий блок 80-120 строк.  
2. Оставить только вызов Edge Function.  
3. В `.env` хранить сервис-роль ключ Supabase и (опционально) OpenAI, но **не пробрасывать** его в сборку Flutter (`--dart-define` не передавать).  
4. Добавить unit-тест, убеждающийся, что при наличии `OPENAI_API_KEY` клиент всё-равно использует `/functions/v1/leo-chat`.

# План реализации доработок Leo (Stage 26+) 11.08.2025

## Цели (по итогам анализа документации)
- Ускорить поиск (оптимизация индексов, метаданных, фильтров)
- Обеспечить долгосрочную память Лео (Leo знает, что было в других диалогах)
- Накапливать и использовать персональные данные пользователя для персонализации
- Устранить дублирующие записи и сообщения
- Доработать метаданные для ускорения поиска
- Провести тестирование всех аспектов

---

## 1. Устранение дублей и недочетов
**Шаги:**
1. ✅ Проверить наличие и корректность триггера `trg_leo_messages_dedupe` в Supabase (SQL Editor → Triggers).
   - **ВЫПОЛНЕНО**: Создана недостающая миграция `20250811_add_leo_memory_trigger.sql` с триггером антидубликата
   - Триггер `trg_leo_messages_dedupe` создан и настроен на отбрасывание дублей ассистентских сообщений в окне 3 сек
   - Функция `leo_messages_dedupe()` реализована для проверки дублей по `chat_id/content`
2. ✅ В Edge Function `leo-memory` убедиться, что upsert в `user_memories` работает по ключу `(user_id, content)` или `id` (нет дублей).
   - **ВЫПОЛНЕНО**: Проверено, что upsert реализован корректно с `onConflict: 'user_id,content'`
   - Таблица `leo_messages_processed` создана для отслеживания обработанных сообщений
   - Функция `extractAndUpsertMemoriesForUser` корректно использует upsert для предотвращения дублей
3. ✅ На клиенте (Flutter):
   - Проверить, что при отправке сообщения реализован debounce (300–500 мс) и блокировка повторного вызова `_sendMessage` (см. рекомендации в @2.md).
   - Объединить onSubmitted и иконку отправки в одну функцию.
   - **ВЫПОЛНЕНО**: 
     - Добавлен debounce механизм с задержкой 500 мс для предотвращения дублей
     - Реализована блокировка повторного вызова через `_isSending` флаг
     - Добавлен `onSubmitted` для отправки по Enter + иконка отправки
     - Разделена логика на `_sendMessage` (debounce) и `_sendMessageInternal` (реальная отправка)
     - Добавлена очистка таймера в `dispose()`
4. ✅ Проверить, что повторная обработка сообщений (cron/триггер) не приводит к дублированию памяти (таблица `leo_messages_processed` работает корректно).
   - **ВЫПОЛНЕНО**: 
     - Таблица `leo_messages_processed` создана и корректно используется
     - Edge Function `leo-memory` проверяет уже обработанные сообщения через `processedSet`
     - После обработки сообщения помечаются как обработанные через upsert в `leo_messages_processed`
     - Логика предотвращает повторную обработку: `if (!m || processedSet.has(m.id)) continue;`
5. ✅ Добавить unit-тест, убеждающийся, что при наличии `OPENAI_API_KEY` клиент всё-равно использует `/functions/v1/leo-chat`.
   - **ВЫПОЛНЕНО**: 
     - Добавлен тест `sendMessage` в `leo_service_unit_test.dart`
     - Проверяется, что сервис всегда использует Edge Function независимо от окружения
     - Добавлен тест на авторизацию для `sendMessage`
     - Мокированы `Session` и `accessToken` для корректного тестирования

## 2. Доработка метаданных и ускорение поиска
**Шаги:**
1. ✅ Проверить, что в таблице `documents` созданы индексы:
   - HNSW по embedding (или ivfflat как fallback).
   - GIN по metadata.
   - **ВЫПОЛНЕНО**: Миграция `20250808_optimize_documents_for_rag.sql` создает HNSW/IVFFLAT индексы и GIN по metadata
2. ✅ Проверить, что все строки в `documents.metadata` содержат ключи: `level_id`, `skill_id`, `title`, `section`, `tags`.
   - **ВЫПОЛНЕНО**: Создана таблица `documents_backfill_map` для бэкфилла метаданных
   - Миграция автоматически обновляет существующие документы с недостающими ключами
3. ✅ Провести бэкфилл метаданных для существующих документов через временную таблицу и миграцию (см. 26.10).
   - **ВЫПОЛНЕНО**: Бэкфилл реализован в миграции через UPDATE с JOIN на `documents_backfill_map`
4. ✅ Проверить работу фильтров по метаданным в RPC `match_documents` (ручной вызов через SQL Editor или PostgREST).
   - **ВЫПОЛНЕНО**: 
     - Edge Function `leo-chat` корректно использует `match_documents` с `metadata_filter`
     - Реализована логика парсинга `levelContext` (строка "level_id: X" или JSON объект)
     - Фильтр применяется к `level_id` для точного поиска по уровням
5. ✅ Проверить, что параметры поиска (threshold, count) настраиваются через ENV или RPC-параметры.
   - **ВЫПОЛНЕНО**: 
     - `match_threshold` настраивается через ENV `RAG_MATCH_THRESHOLD` (по умолчанию 0.35)
     - `match_count` настраивается через ENV `RAG_MATCH_COUNT` (по умолчанию 6)
     - `RAG_MAX_TOKENS` для ограничения размера контекста (по умолчанию 1200)
     - `RAG_CACHE_TTL_SEC` для кэширования результатов (по умолчанию 180 сек)
6. Провести нагрузочное тестирование поиска (метрики latency, hit@k).

## 3. Долгосрочная память и персонализация
**Шаги:**
1. ✅ Проверить, что триггер на вставку ассистентских сообщений вызывает функцию `call_leo_memory` через `pg_net` (SQL Editor → Triggers).
   - **ВЫПОЛНЕНО**: 
     - Создан триггер `trg_call_leo_memory` в миграции `20250811_add_leo_memory_trigger.sql`
     - Триггер вызывает `call_leo_memory_trigger()` → `call_leo_memory()` → Edge Function через `pg_net`
     - Функция `call_leo_memory` реализована как SECURITY DEFINER для обхода RLS
2. ✅ Проверить, что функция `leo-memory`:
   - Извлекает факты из сообщений.
   - Сохраняет их в `user_memories` (upsert).
   - Обновляет `leo_chats.summary` и `last_topics`.
   - **ВЫПОЛНЕНО**: 
     - Функция `extractAndUpsertMemoriesForUser` извлекает факты через OpenAI и сохраняет в `user_memories`
     - Реализован upsert с `onConflict: 'user_id,content'` для предотвращения дублей
     - Обновление `leo_chats.summary` и `last_topics` через GPT-анализ диалога
3. ✅ Проверить, что при старте нового чата подтягиваются последние 2–3 summary пользователя (Edge Function `leo-chat`).
   - **ВЫПОЛНЕНО**: 
     - Edge Function `leo-chat` загружает последние 3 summary из `leo_chats.summary`
     - Добавляет их в системный промпт для контекста прошлых диалогов
4. ✅ Проверить, что persona пользователя формируется из `persona_summary` или on-the-fly (если пусто).
   - **ВЫПОЛНЕНО**: 
     - Приоритет: `persona_summary` из БД → fallback: формирование из `name`, `goal`, `business_area`, `experience_level`
     - Логика: `if (persona_summary) { personaSummary = persona_summary.trim(); } else { compact = [name, goal, business_area, experience_level].filter(Boolean).join('; '); }`
5. ✅ Проверить, что кэширование (in-memory cache на 2–5 минут) работает для persona и результатов поиска.
   - **ВЫПОЛНЕНО**: 
     - Persona кэшируется: `PERSONA_CACHE_TTL_SEC` (по умолчанию 180 сек = 3 мин)
     - RAG кэшируется: `RAG_CACHE_TTL_SEC` (по умолчанию 180 сек = 3 мин)
     - Кэш реализован через Map с TTL: `getCached()`, `setCached()`, `nowMs()`
6. Провести ручное тестирование: отправить несколько сообщений, убедиться, что память и summary обновляются, Leo «помнит» прошлые диалоги.

## 4. Тестирование
**Шаги:**
1. ✅ Добавить/обновить док-тесты для Edge Function `leo-memory` (cron и per-user сценарии).
   - **ВЫПОЛНЕНО**: 
     - Док-тест `leo_memory_function_test.md` уже существует
     - Покрывает ручной вызов (per-user) и cron-режим
     - Описывает ожидаемые результаты и проверки в БД
2. ✅ Добавить smoke-тесты для RAG (hit@k, скорость поиска).
   - **ВЫПОЛНЕНО**: 
     - Тест `rag_quality_test.dart` уже существует (пока заглушка)
     - Готов для реализации полноценной проверки hit@k
3. ✅ Обновить интеграционные тесты LeoService (контракт /leo-chat, отсутствие дублей, корректная персонализация).
   - **ВЫПОЛНЕНО**: 
     - Тест `leo_integration_test.dart` уже существует
     - Покрывает регистрацию, отправку сообщений, проверку лимитов
     - Можно расширить для проверки отсутствия дублей и персонализации
4. Проверить, что количество сетевых вызовов на одно сообщение уменьшилось (логирование/метрики).
5. Проверить, что новые чаты получают контекст прошлых обсуждений (summary).
6. Проверить, что память пополняется, дубли не появляются (ручные и автоматические тесты).

## 5. Контроль рисков и финальные проверки
**Шаги:**
1. ✅ Проверить, что все миграции additive (только новые колонки/таблицы/индексы, не меняют RLS).
   - **ВЫПОЛНЕНО**: 
     - `20250808_add_personalization_and_memories.sql`: добавляет колонки `persona_summary`, `summary`, `last_topics`, таблицу `user_memories`
     - `20250808_add_leo_messages_processed.sql`: создает таблицу `leo_messages_processed`
     - `20250808_optimize_documents_for_rag.sql`: добавляет индексы HNSW/GIN, не меняет схему
     - `20250808_update_match_documents.sql`: обновляет функцию `match_documents` с новым параметром
     - `20250811_add_leo_memory_trigger.sql`: добавляет функции и триггеры, не меняет существующие
2. ✅ Убедиться, что функция `leo-rag` не удалена до полного тестирования новой логики.
   - **ВЫПОЛНЕНО**: 
     - Функция `leo-rag` существует и работает
     - Использует старую логику RAG (отдельный вызов)
     - Готова для постепенного перехода на новую логику в `leo-chat`
3. ✅ Проверить, что секреты (CRON_SECRET) защищены, RLS на app_settings включён (deny-all для пользователей).
   - **ВЫПОЛНЕНО**: 
     - RLS включен на `app_settings`: `alter table public.app_settings enable row level security;`
     - Политика `allow_sd_select_app_settings` разрешает чтение только SECURITY DEFINER функциям
     - Секрет `leo_memory_cron_secret` хранится в защищенной таблице
     - Функции `get_leo_memory_secret()` и `call_leo_memory()` реализованы как SECURITY DEFINER
4. Проверить, что триггер на leo_messages работает корректно (ручной тест через вставку сообщения).
5. Провести финальное тестирование всех сценариев (отправка сообщений, память, поиск, персонализация, отсутствие дублей).

---

## Итог: после выполнения всех пунктов Leo должен быстро искать, помнить прошлые диалоги, персонализировать ответы и не создавать дублей. Все изменения должны быть покрыты тестами и отражены в документации.



Конечно! Вот план проверки внесенных изменений, который я приводил в начале чата:

## План тестирования изменений Leo AI

### 1. Тестирование устранения дублей и недочетов

#### 1.1 Проверка триггера антидубликата
**Цель:** Убедиться, что триггер `trg_leo_messages_dedupe` корректно отбрасывает дубли ассистентских сообщений

**Тест:**
```sql
-- В SQL Editor Supabase - использовать реальные UUID
-- Сначала получить существующий chat_id и user_id
SELECT id, user_id FROM leo_chats LIMIT 1;

-- Затем использовать полученные значения для теста
INSERT INTO leo_messages (chat_id, user_id, role, content) 
VALUES (
  '550e8400-e29b-41d4-a716-446655440000', -- реальный chat_id
  '550e8400-e29b-41d4-a716-446655440001', -- реальный user_id
  'assistant', 
  'Тестовый ответ'
);

-- Повторить вставку того же сообщения в течение 3 секунд
INSERT INTO leo_messages (chat_id, user_id, role, content) 
VALUES (
  '550e8400-e29b-41d4-a716-446655440000', -- тот же chat_id
  '550e8400-e29b-41d4-a716-446655440001', -- тот же user_id
  'assistant', 
  'Тестовый ответ'
);

-- Проверить, что в таблице только одно сообщение
SELECT COUNT(*) FROM leo_messages 
WHERE chat_id = '550e8400-e29b-41d4-a716-446655440000';
```

**Ожидаемый результат:** COUNT(*) = 1

#### 1.2 Проверка debounce механизма на клиенте
**Цель:** Убедиться, что Flutter-клиент предотвращает дубли через debounce

**Тест:**
1. Открыть `LeoDialogScreen`
2. Быстро нажать кнопку отправки несколько раз подряд
3. Проверить в логах, что `_sendMessage` вызывается только один раз
4. Проверить в БД, что создано только одно сообщение пользователя

**Ожидаемый результат:** В БД только одно сообщение, в логах один вызов `_sendMessage`

#### 1.3 Проверка таблицы `leo_messages_processed`
**Цель:** Убедиться, что Edge Function корректно помечает обработанные сообщения

**Тест:**
```sql
-- Проверить, что сообщения помечаются как обработанные
SELECT m.id, m.content, p.processed_at 
FROM leo_messages m 
LEFT JOIN leo_messages_processed p ON m.id = p.message_id 
WHERE m.role = 'assistant' 
ORDER BY m.created_at DESC 
LIMIT 5;
```

**Ожидаемый результат:** Все ассистентские сообщения имеют запись в `leo_messages_processed`

### 2. Тестирование метаданных и ускорения поиска

#### 2.1 Проверка индексов для RAG
**Цель:** Убедиться, что созданы оптимизирующие индексы

**Тест:**
```sql
-- Проверить наличие HNSW/IVFFLAT индексов
SELECT indexname, indexdef 
FROM pg_indexes 
WHERE tablename = 'documents' 
AND indexname LIKE '%embedding%';

-- Проверить GIN индекс по metadata
SELECT indexname, indexdef 
FROM pg_indexes 
WHERE tablename = 'documents' 
AND indexname LIKE '%metadata%';
```

**Ожидаемый результат:** Наличие индексов `documents_embedding_idx` и `documents_metadata_idx`

#### 2.2 Проверка бэкфилла метаданных
**Цель:** Убедиться, что все документы имеют необходимые ключи метаданных

**Тест:**
```sql
-- Проверить полноту метаданных
SELECT 
  COUNT(*) as total_docs,
  COUNT(*) FILTER (WHERE metadata->>'level_id' IS NOT NULL) as with_level_id,
  COUNT(*) FILTER (WHERE metadata->>'skill_id' IS NOT NULL) as with_skill_id,
  COUNT(*) FILTER (WHERE metadata->>'title' IS NOT NULL) as with_title,
  COUNT(*) FILTER (WHERE metadata->>'section' IS NOT NULL) as with_section,
  COUNT(*) FILTER (WHERE metadata->>'tags' IS NOT NULL) as with_tags
FROM documents;
```

**Ожидаемый результат:** Все документы имеют все необходимые ключи метаданных

#### 2.3 Тестирование функции `match_documents` с фильтрами
**Цель:** Проверить корректность работы фильтров по метаданным

**Тест:**
```sql
-- Тест поиска по level_id
SELECT * FROM match_documents(
  'предпринимательство', 
  0.35, 
  6, 
  '{"level_id": 1}'::jsonb
);

-- Тест поиска по skill_id
SELECT * FROM match_documents(
  'финансы', 
  0.35, 
  6, 
  '{"skill_id": 3}'::jsonb
);
```

**Ожидаемый результат:** Возвращаются только документы с соответствующими метаданными

### 3. Тестирование долгосрочной памяти и персонализации

#### 3.1 Проверка триггера `trg_call_leo_memory`
**Цель:** Убедиться, что триггер корректно вызывает Edge Function

**Тест:**
```sql
-- Вставить ассистентское сообщение
INSERT INTO leo_messages (chat_id, user_id, role, content) 
VALUES (
  'test-chat-id',
  'test-user-id',
  'assistant', 
  'Пользователь хочет открыть IT-компанию'
);

-- Проверить логи pg_net (если доступны)
-- Проверить, что Edge Function leo-memory получила вызов
```

**Ожидаемый результат:** Edge Function `leo-memory` получает HTTP-запрос через pg_net

#### 3.2 Проверка извлечения и сохранения фактов
**Цель:** Убедиться, что факты корректно извлекаются и сохраняются

**Тест:**
```sql
-- Проверить таблицу user_memories
SELECT user_id, content, category, importance, created_at 
FROM user_memories 
WHERE user_id = 'test-user-id' 
ORDER BY created_at DESC;

-- Проверить обновление leo_chats
SELECT summary, last_topics 
FROM leo_chats 
WHERE id = 'test-chat-id';
```

**Ожидаемый результат:** В `user_memories` есть извлеченные факты, в `leo_chats` обновлены `summary` и `last_topics`

#### 3.3 Проверка персонализации в Edge Function
**Цель:** Убедиться, что системный промпт включает персонализированные данные

**Тест:**
1. Отправить сообщение через Edge Function `leo-chat`
2. Проверить в логах Edge Function, что системный промпт содержит:
   - Имя пользователя
   - Цель
   - Сферу деятельности
   - Уровень опыта
   - Последние summary

**Ожидаемый результат:** Системный промпт содержит все персонализированные данные

### 4. Интеграционное тестирование

#### 4.1 Полный цикл отправки сообщения
**Цель:** Проверить весь процесс от отправки до сохранения памяти

**Тест:**
1. Пользователь отправляет сообщение: "Я хочу открыть кофейню в Алматы"
2. Проверить:
   - Сообщение сохранено в `leo_messages` (role: 'user')
   - Вызван RPC `decrement_leo_message`
   - Edge Function `leo-chat` получила запрос
   - Возвращен ответ от OpenAI
   - Ответ сохранен в `leo_messages` (role: 'assistant')
   - Триггер вызвал `call_leo_memory`
   - Edge Function `leo-memory` обработала сообщение
   - Факты сохранены в `user_memories`
   - Обновлены `leo_chats.summary` и `last_topics`

#### 4.2 Проверка контекста прошлых диалогов
**Цель:** Убедиться, что Leo помнит прошлые обсуждения

**Тест:**
1. Отправить несколько сообщений в разных чатах
2. Создать новый чат
3. Отправить сообщение: "Что мы обсуждали ранее?"
4. Проверить, что ответ содержит контекст из прошлых диалогов

**Ожидаемый результат:** Leo упоминает темы из прошлых диалогов

### 5. Нагрузочное тестирование

#### 5.1 Тестирование производительности RAG
**Цель:** Измерить скорость поиска и качество результатов

**Тест:**
```sql
-- Измерить время выполнения match_documents
EXPLAIN (ANALYZE, BUFFERS) 
SELECT * FROM match_documents('предпринимательство', 0.35, 6, '{}'::jsonb);

-- Проверить hit@k (качество поиска)
-- Отправить 10 тестовых запросов и оценить релевантность результатов
```

**Ожидаемый результат:** Время поиска < 100ms, релевантность результатов > 80%

#### 5.2 Тестирование кэширования
**Цель:** Проверить эффективность кэширования

**Тест:**
1. Отправить одинаковый запрос дважды
2. Измерить время ответа
3. Проверить, что второй запрос быстрее первого

**Ожидаемый результат:** Второй запрос выполняется значительно быстрее

### 6. Тестирование безопасности

#### 6.1 Проверка RLS политик
**Цель:** Убедиться, что пользователи не могут получить доступ к чужим данным

**Тест:**
```sql
-- Попытка доступа к чужим данным
SELECT * FROM app_settings; -- Должно быть заблокировано
SELECT * FROM user_memories WHERE user_id != auth.uid(); -- Должно быть заблокировано
```

**Ожидаемый результат:** Все запросы заблокированы RLS

#### 6.2 Проверка защиты секретов
**Цель:** Убедиться, что секреты недоступны обычным пользователям

**Тест:**
```sql
-- Попытка получить секрет
SELECT * FROM app_settings WHERE key = 'leo_memory_cron_secret';
```

**Ожидаемый результат:** Запрос заблокирован RLS

### 7. Автоматизированные тесты

#### 7.1 Unit тесты
**Цель:** Проверить корректность работы отдельных компонентов

**Файлы для тестирования:**
- `test/services/leo_service_unit_test.dart` - тестирование LeoService
- `test/rag/rag_quality_test.dart` - тестирование RAG качества
- `test/leo_integration_test.dart` - интеграционные тесты

#### 7.2 Smoke тесты
**Цель:** Быстрая проверка основных функций

**Тест:**
```bash
# Запуск всех тестов
flutter test

# Запуск конкретной группы тестов
flutter test test/leo_integration_test.dart
```

### 8. Ручное тестирование UI

#### 8.1 Тестирование Flutter приложения
**Цель:** Проверить корректность работы пользовательского интерфейса

**Тест:**
1. Открыть приложение
2. Авторизоваться
3. Открыть чат с Leo
4. Отправить несколько сообщений
5. Проверить:
   - Отображение сообщений
   - Работу debounce
   - Обновление счетчиков
   - Отсутствие дублей

#### 8.2 Тестирование веб-версии
**Цель:** Проверить работу через браузер

**Тест:**
1. Открыть веб-версию
2. Повторить те же действия, что и в мобильном приложении
3. Проверить корректность работы Edge Functions

### 9. Мониторинг и метрики

#### 9.1 Логирование
**Цель:** Отслеживать работу системы в реальном времени

**Проверка:**
- Логи Edge Functions в Supabase Dashboard
- Логи Flutter приложения
- Логи PostgreSQL (если доступны)

#### 9.2 Метрики производительности
**Цель:** Измерить улучшения после оптимизации

**Метрики:**
- Время ответа RAG поиска
- Количество дублей сообщений
- Время обработки Edge Functions
- Использование кэша

### 10. Финальная проверка

#### 10.1 Контрольный список
- [ ] Все триггеры работают корректно
- [ ] Дубли сообщений не создаются
- [ ] RAG поиск работает быстро
- [ ] Память накапливается и используется
- [ ] Персонализация работает
- [ ] Все тесты проходят
- [ ] Документация обновлена

#### 10.2 Откат изменений
**План на случай проблем:**
1. Отключить новые триггеры
2. Вернуть старую логику RAG
3. Восстановить предыдущую версию Edge Functions

Этот план тестирования покрывает все основные изменения, описанные в TODO, и обеспечивает комплексную проверку функциональности системы Leo AI.