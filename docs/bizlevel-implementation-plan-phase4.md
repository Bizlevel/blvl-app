# План реализации BizLevel v2.1 - Фаза 14-16: Рефакторинг и стабилизация архитектуры

Настоящий план основан на результатах технического аудита и направлен на устранение ключевых архитектурных недостатков, повышение тестируемости и стабильности приложения. Задачи разбиты на атомарные операции для последовательного и безопасного выполнения.

## Этап 14: Фундаментальный рефакторинг и DI

### Задача 14.1: Исправление бага в логике онбординга
- **Файлы:** `lib/services/auth_service.dart`
- **Компоненты:** `AuthService`
- **Что делать:**
  1. В методе `updateProfile` изменить жестко заданное значение `onboarding_completed: false`. Логика должна позволять устанавливать это поле в `true` или обновлять профиль, не затрагивая его.
  2. Рекомендуемое решение: добавить необязательный параметр `bool? onboardingCompleted`.
- **Почему это важно:**
  Критический баг, который ломает ключевую логику онбординга.
- **Проверка результата:**
  Вызов `updateProfile` с `onboardingCompleted: true` корректно обновляет поле в БД. Вызов без этого параметра не изменяет существующее значение.

### Задача 14.2: Преобразование AuthService в инстанцируемый класс
- **Файлы:** `lib/services/auth_service.dart`, `lib/services/supabase_service.dart`
- **Компоненты:** `AuthService`, `SupabaseService`, `Riverpod Providers`
- **Что делать:**
  1. Создать провайдер `supabaseClientProvider`, который будет возвращать `SupabaseService.client`.
  2. В `AuthService` убрать `static` у всех методов. Класс больше не должен быть синглтоном.
  3. Создать конструктор для `AuthService`, который принимает `SupabaseClient`.
  4. Создать `authServiceProvider = Provider<AuthService>((ref) => AuthService(ref.watch(supabaseClientProvider)))`.
- **Почему это важно:**
  Это **фундаментальный шаг** для внедрения Dependency Injection. Он подготавливает сервис к использованию в тестах и в других частях приложения через DI.
- **Проверка результата:**
  `AuthService` является обычным классом. Провайдер `authServiceProvider` успешно его создает. Приложение пока не будет компилироваться, это нормально.

### Задача 14.3: Миграция потребителей AuthService на использование провайдера
- **Файлы:** `lib/screens/auth/login_screen.dart`, `lib/providers/auth_provider.dart` и другие места, где вызывается `AuthService`.
- **Зависимости:** 14.2
- **Компоненты:** `LoginScreen`, `currentUserProvider`
- **Что делать:**
  1. Найти все вызовы `AuthService.staticMethod()` в проекте.
  2. Заменить их на `ref.read(authServiceProvider).instanceMethod()` (в методах) или `ref.watch(authServiceProvider)` (в `build` методах).
  3. Для классовых виджетов передавать `WidgetRef` в методы.
- **Почему это важно:**
  Завершает переход на DI, полностью отвязывая UI и другие провайдеры от статической реализации сервиса.
- **Проверка результата:**
  Проект компилируется. Статические вызовы `AuthService` полностью отсутствуют. Функционал логина работает как прежде.

### Задача 14.4: Устранение дублирования кода в `AuthService`
- **Файлы:** `lib/services/auth_service.dart`
- **Зависимости:** 14.3
- **Компоненты:** `AuthService`
- **Что делать:**
  1. Создать приватный метод-обертку, например `_handleAuthCall`, который содержит общий блок `try-catch`.
  2. Рефакторить публичные методы (`signIn`, `signUp`, `signOut`, `updateProfile`) для использования этой обертки.
- **Почему это важно:**
  Соответствие принципу DRY. Упрощает поддержку логики обработки ошибок.
- **Проверка результата:**
  Дублирующиеся блоки `try-catch` удалены. Логика обработки ошибок централизована и работает корректно.

## Этап 15: Внедрение GoRouter и рефакторинг навигации

### Задача 15.1: Установка и базовая настройка `GoRouter`
- **Файлы:** `pubspec.yaml`, `lib/main.dart`, новый `lib/routing/app_router.dart`
- **Компоненты:** `GoRouter`, `MaterialApp`
- **Что делать:**
  1. Добавить `go_router` в `pubspec.yaml`.
  2. Создать файл `app_router.dart` и определить в нем `GoRouter` через `Riverpod` провайдер.
  3. Определить основные маршруты: `/login`, `/register`, `/home`.
  4. В `main.dart` заменить `MaterialApp` на `MaterialApp.router` и подключить конфигурацию роутера.
- **Почему это важно:**
  Создает основу для централизованной системы навигации.
- **Проверка результата:**
  Приложение запускается с `GoRouter`. Открытие стартовой страницы (`/login`) работает.

### Задача 15.2: Реализация `AuthGate` через `redirect` в `GoRouter`
- **Файлы:** `lib/routing/app_router.dart`, `lib/main.dart`
- **Зависимости:** 15.1
- **Компоненты:** `GoRouter redirect`, `authStateProvider`
- **Что делать:**
  1. В конфигурации `GoRouter` добавить секцию `redirect`.
  2. В `redirect` добавить логику, которая будет слушать `authStateProvider` и проверять текущий маршрут.
  3. Если пользователь не аутентифицирован и пытается зайти не на `/login` или `/register`, перенаправлять его на `/login`.
  4. Если пользователь аутентифицирован и находится на `/login`, перенаправлять его на `/home`.
  5. Удалить старую логику роутинга из виджета `MyApp` в `main.dart`.
- **Почему это важно:**
  Централизует всю логику авторизационных переходов в одном месте, делая ее предсказуемой и легко поддерживаемой.
- **Проверка результата:**
  Пользователь без сессии автоматически попадает на `/login`. После успешного входа его перебрасывает на `/home`.

### Задача 15.3: Рефакторинг `LoginScreen` для управления UI-состоянием через Riverpod
- **Файлы:** `lib/screens/auth/login_screen.dart`
- **Зависимости:** 14.3
- **Компоненты:** `LoginScreen`, `StateNotifier`
- **Что делать:**
  1. Создать `LoginController` (`StateNotifier<bool>`) для управления состоянием загрузки кнопки.
  2. В `LoginScreen` заменить `ConsumerStatefulWidget` на `ConsumerWidget`.
  3. Удалить локальное состояние `_isLoading` и `setState`.
  4. Кнопка "Войти" должна менять свое состояние (текст/индикатор) на основе `ref.watch(loginControllerProvider)`.
  5. `onPressed` должен вызывать `ref.read(loginControllerProvider.notifier).signIn(...)`.
- **Почему это важно:**
  Переход на идиоматичное для Riverpod управление состоянием. Делает виджет проще и готовит его к тестированию.
- **Проверка результата:**
  Экран входа работает как раньше, но без использования `StatefulWidget` и `setState`.

## Этап 16: Слой данных и Тестирование

### Задача 16.1: Создание `UserRepository` и рефакторинг `currentUserProvider`
- **Файлы:** новый `lib/repositories/user_repository.dart`, `lib/providers/auth_provider.dart`
- **Зависимости:** 14.3
- **Компоненты:** `UserRepository`, `currentUserProvider`
- **Что делать:**
  1. Создать класс `UserRepository`, принимающий `SupabaseClient`.
  2. Перенести логику запроса к таблице `users` из `currentUserProvider` в метод `fetchProfile(userId)` в `UserRepository`.
  3. Создать `userRepositoryProvider`.
  4. `currentUserProvider` должен зависеть от `userRepositoryProvider` для получения данных.
- **Почему это важно:**
  Абстрагирует доступ к данным, улучшает структуру и позволяет переиспользовать логику запросов.
- **Проверка результата:**
  Данные пользователя загружаются через `UserRepository`, `currentUserProvider` не содержит прямых вызовов к Supabase.

### Задача 16.2: Написание Unit-тестов для `AuthService`
- **Файлы:** `test/services/auth_service_test.dart`
- **Зависимости:** 14.2, `mocktail`
- **Компоненты:** `flutter_test`
- **Что делать:**
  1. Добавить `mocktail` в `dev_dependencies`.
  2. Написать тесты для `AuthService`, используя "мок" `SupabaseClient`. Проверить, что сервис вызывает правильные методы клиента и корректно обрабатывает исключения.
- **Почему это важно:**
  Гарантирует, что ключевая логика аутентификации работает корректно и защищена от регрессий.
- **Проверка результата:**
  Выполнение `flutter test test/services/auth_service_test.dart` проходит успешно.

### Задача 16.3: Написание Widget-теста для `LoginScreen`
- **Файлы:** `test/screens/auth/login_screen_test.dart`
- **Зависимости:** 15.3, 16.2
- **Компоненты:** `flutter_test`, `mocktail`
- **Что делать:**
  1. Написать widget-тест для `LoginScreen`.
  2. Использовать `ProviderScope(overrides: ...)` для подмены `authServiceProvider` и `loginControllerProvider` на мок-версии.
  3. Проверить, что при ошибке от `signIn` показывается `SnackBar`.
  4. Проверить, что во время загрузки на кнопке отображается `CircularProgressIndicator`.
- **Почему это важно:**
  Проверяет корректность взаимодействия UI с бизнес-логикой без реальных сетевых запросов.
- **Проверка результата:**
  Выполнение `flutter test test/screens/auth/login_screen_test.dart` проходит успешно.
