### Отчёт по улучшениям Leo (Этап 26) — что сделано, зачем и как изменилось

Этот документ фиксирует изменения, внесённые в рамках работ по улучшению ИИ‑чата Leo (Stage 26) и последующих исправлений в этой сессии. Содержит: цели, «как было», «как стало», список изменений в Supabase и клиенте, результаты проверок, а также оставшиеся риски и следующие шаги.

## Краткая сводка
- В БД добавлены сущности для персонализации и памяти: `users.persona_summary`, `leo_chats.summary/last_topics`, таблица `user_memories` с векторами и RLS.
- RAG интегрирован в `supabase/functions/leo-chat` (один конец вместо отдельных вызовов), добавлены кэши и лимиты контекста.
- Создана функция `supabase/functions/leo-memory` для извлечения фактов и свёрток; включён вызов из Postgres-триггера через `pg_net`.
- Исправлены проблемы: отсутствие вызова памяти из триггера (RLS/pg_net), дубли ассистентских сообщений (добавлен серверный дедуп‑триггер).

## Как было (до работ Stage 26)
- Контекст RAG получался с клиента отдельным вызовом, увеличивая задержку и усложняя логику.
- Не было долговременной памяти: факты о пользователе не сохранялись, свёртки чатов отсутствовали.
- Фильтрация RAG по `levelContext` отсутствовала или была слабой.
- В документах не было полноценных индексов/метаданных для качественного поиска.

## Как стало (после работ Stage 26)
- Один эндпоинт `/leo-chat` формирует ответ: подключён RAG, персонализация (persona), личная память (user_memories), и сводки прошлых чатов.
- Кэши в памяти функций (TTL) снижают нагрузку: персоны, RAG, сводки чатов.
- Включена долговременная память: `leo-memory` извлекает факты и сохраняет в `user_memories`, обновляет `leo_chats.summary/last_topics`.
- RAG фильтруется по `metadata_filter` (на основе `levelContext`), RPC `match_documents` принимает jsonb‑фильтр.
- Документы оптимизированы: HNSW индекс по векторам, GIN по `metadata`, добавлен backfill‑механизм.

## Изменения в Supabase (основные)
1) Миграции (созданы ранее в репозитории):
   - `20250808_add_personalization_and_memories.sql` — поля персонализации и таблица `user_memories` (RLS, индексы).
   - `20250808_add_leo_messages_processed.sql` — маркеры обработанных сообщений для фоновой обработки.
   - `20250808_optimize_documents_for_rag.sql` — индексы и метаданные у `documents`.
   - `20250808_update_match_documents.sql` — новый RPC с `metadata_filter` (jsonb).
   - `20250811_add_leo_memory_trigger.sql` — `app_settings`, `pg_net`, `call_leo_memory` + триггер на `leo_messages`.

2) Исправления в этой сессии (Root cause и фиксы):
   - Проблема: `leo-memory` не вызывался из триггера. Причины:
     - Неверная сигнатура вызова `pg_net` и/или не тот schema‑префикс.
     - RLS/политики мешали чтению секрета в `app_settings`.
   - Что сделано:
     - Пересоздан `public.call_leo_memory(...)` как SECURITY DEFINER. Вызов `pg_net` приведён к корректной сигнатуре:
       `net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds int)`.
     - Вынесено чтение секрета в `public.get_leo_memory_secret()` (SECURITY DEFINER) и использовано внутри `call_leo_memory`.
     - Добавлена политика `allow_sd_select_app_settings` (FOR SELECT USING (true)). Привилегии на таблицу внешним ролям не выдавались, поэтому доступ остаётся только у ролей с правами (функции под дефайнером).
     - Пересоздан AFTER INSERT триггер: `trg_call_leo_memory` → вызывает `call_leo_memory_trigger()` (SECURITY DEFINER), который дергает `call_leo_memory`.
     - Добавлен BEFORE INSERT триггер‑антидубликат `trg_leo_messages_dedupe` c функцией `leo_messages_dedupe()` — отбрасывает ассистентские сообщения, совпадающие по `chat_id/content` в окне 3 сек.
   - Проверки:
     - Секрет присутствует: `public.app_settings('leo_memory_cron_secret') = 'Cron_Bizlevel_2025'`.
     - `pg_net` установлен, сигнатура обнаружена в схеме `net`.
     - Ручно переотправили 2 последние ассистентские реплики в `call_leo_memory(...)` для пользователя `deus2111@gmail.com`.

## Изменения в Edge Functions
- `supabase/functions/leo-chat`: интегрирован RAG, персонализация, память; кэши; ограничение по токенам; подмешивание сводок прошлых чатов при старте нового диалога.
- `supabase/functions/leo-memory`: извлечение атомарных фактов, батч‑эмбеддинги и upsert в `user_memories`, свёртка чатов (`leo_chats.summary`, `last_topics`), обработка событий от триггера (`job` из Postgres) и по cron.

## Изменения в клиенте
- `lib/services/leo_service.dart`: единый метод `sendMessage()` на `/leo-chat` вместо раздельных путей; передача `userContext/levelContext/knowledgeContext` опционально.
- UI `leo_dialog_screen`: использует унифицированный сервис. Рекомендации (важно): заблокировать повторный вызов `_sendMessage` при `_isSending==true`, объединить `onSubmitted`/иконку отправки и добавить debounce 300–500 мс — это устранит источник дублей на стороне клиента.

## Диагностика инцидента (данная сессия)
**Симптомы:**
- Дубли ассистента в диалоге (исчезали после перезагрузки).
- Leo «не помнит» прошлый диалог (на скриншоте).

**Что нашли:**
- В логах Flutter виден многократный вызов `_sendMessage` и повторные переходы на `/chat`. Это провоцирует двойную отправку.
- В БД за последние 10 минут у пользователя 2 чата; поля `summary/last_topics` пустые, в памяти записи отсутствовали — значит `leo-memory` не вызывался/не проходил авторизацию.
- Логи Edge: 401 на POST к `functions/v1/leo-memory` — несоответствие сигнатуры `pg_net`/RLS‑блокировка секрета.

**Что исправили:** см. раздел «Исправления в этой сессии» — приведён вызов `pg_net`, обеспечен доступ к секрету через SECURITY DEFINER, добавлен антидубликат‑триггер.

**Ожидаемое поведение после фикса:**
- После вставки новой ассистентской реплики триггер отправляет `job` в `leo-memory` (HTTP 202). Функция сохраняет факты в `user_memories` и обновляет `leo_chats.summary/last_topics`.
- При старте нового чата `/leo-chat` подтянет 2–3 последних `summary` и корректно ответит на вопрос про прошлый диалог.
- Быстрые дубли ассистента (идентичный текст < 3 сек) будут отброшены на уровне БД.

## Результаты проверок (после фиксов)
- Ручные вызовы `call_leo_memory` по двум последним чатам отправлены без SQL‑ошибок.
- Edge‑логи 401 исчезли; ожидаем появление `summary/last_topics` после обработки `leo-memory` (асинхронно, HTTP 202).

## Риски и следующие шаги
- Убедиться, что ENV `CRON_SECRET` в Edge‑функции `leo-memory` совпадает с `public.app_settings.leo_memory_cron_secret`.
- На клиенте ввести защиту от повторного `_sendMessage` (см. рекомендации выше).
- Для лучшего RAG‑фильтра: передавать структурный `levelContext` вида `{ "level_id": 6 }`.
- После подтверждения стабильности можно ужесточить доступ к `app_settings` (оставить SECURITY DEFINER без широкой политики, если не требуется).

---
Документ будет обновляться по мере поступления новых результатов тестов и телеметрии.

