import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class BizLevelMapScreen extends ConsumerStatefulWidget {
  const BizLevelMapScreen({super.key});

  @override
  ConsumerState<BizLevelMapScreen> createState() => _BizLevelMapScreenState();
}

class _BizLevelMapScreenState extends ConsumerState<BizLevelMapScreen> {
  final ScrollController _scrollController = ScrollController();
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        centerTitle: true,
        title: const Text('Башня БизЛевел'),
        backgroundColor: AppColor.appBarColor,
      ),
      body: Consumer(
        builder: (context, ref, _) {
          final nodesAsync = ref.watch(towerNodesProvider);
          
          return nodesAsync.when(
            data: (nodes) {
              final levelNodes = nodes
                  .where((n) => n['type'] == 'level')
                  .toList();
              
              return _buildZigzagMap(context, levelNodes);
            },
            loading: () => const Center(child: CircularProgressIndicator()),
            error: (e, st) => Center(child: Text('Ошибка: $e')),
          );
        },
      ),
    );
  }
  
  Widget _buildZigzagMap(BuildContext context, List<dynamic> levelNodes) {
    // Константы для сетки
    const double nodeSize = 88.0;
    const double horizontalSpacing = 120.0; // Расстояние между колонками
    const double verticalSpacing = 120.0;   // Расстояние между строками
    const double sidePadding = 40.0;
    
    // Генерируем позиции для зигзага
    final positions = _generateZigzagPositions(levelNodes.length);
    
    // Вычисляем размер canvas
    final maxRow = positions.map((p) => p.row).reduce((a, b) => a > b ? a : b);
    final canvasHeight = (maxRow + 1) * verticalSpacing + 200;
    final canvasWidth = MediaQuery.of(context).size.width;
    
    // Преобразуем позиции в Offset
    final nodeOffsets = positions.map((pos) {
      return Offset(
        sidePadding + pos.column * horizontalSpacing + nodeSize / 2,
        canvasHeight - (pos.row * verticalSpacing + 100), // Инвертируем Y, чтобы начать снизу
      );
    }).toList();
    
    return SingleChildScrollView(
      controller: _scrollController,
      reverse: true, // Начинаем снизу
      child: SizedBox(
        height: canvasHeight,
        width: canvasWidth,
        child: Stack(
          children: [
            // Слой с дорожками
            Positioned.fill(
              child: CustomPaint(
                painter: ZigzagPathPainter(
                  nodeOffsets: nodeOffsets,
                  levelNodes: levelNodes,
                ),
              ),
            ),
            // Слой с уровнями
            ...List.generate(levelNodes.length, (index) {
              final node = levelNodes[index];
              final offset = nodeOffsets[index];
              
              return Positioned(
                left: offset.dx - nodeSize / 2,
                top: offset.dy - nodeSize / 2,
                child: _buildLevelNode(
                  context,
                  node: node,
                  index: index,
                ),
              );
            }),
          ],
        ),
      ),
    );
  }
  
  List<GridPosition> _generateZigzagPositions(int count) {
    final positions = <GridPosition>[];
    int row = 0;
    int column = 1; // Средняя колонка (0 - левая, 1 - средняя, 2 - правая)
    
    // Паттерн движения: центр -> лево -> лево-верх -> центр-верх -> право-верх -> право -> центр
    final pattern = [
      GridPosition(1, 0), // Уровень 1 - центр
      GridPosition(0, 0), // Уровень 2 - лево
      GridPosition(0, 1), // Уровень 3 - лево-верх
      GridPosition(1, 1), // Уровень 4 - центр-верх
      GridPosition(2, 1), // Уровень 5 - право-верх
      GridPosition(2, 2), // Уровень 6 - право-верх
      GridPosition(1, 2), // Уровень 7 - центр-верх
      GridPosition(0, 2), // Уровень 8 - лево-верх
      GridPosition(0, 3), // Уровень 9 - лево-верх
      GridPosition(1, 3), // Уровень 10 - центр-верх
    ];
    
    for (int i = 0; i < count && i < pattern.length; i++) {
      positions.add(pattern[i]);
    }
    
    // Если уровней больше 10, продолжаем паттерн
    if (count > pattern.length) {
      // Продолжаем зигзаг дальше
      for (int i = pattern.length; i < count; i++) {
        // Здесь можно добавить логику для продолжения паттерна
        positions.add(GridPosition(1, 3 + (i - pattern.length)));
      }
    }
    
    return positions;
  }
  
  Widget _buildLevelNode(
    BuildContext context, {
    required Map<String, dynamic> node,
    required int index,
  }) {
    final data = node['data'] as Map<String, dynamic>;
    final bool isCompleted = data['isCompleted'] == true;
    final bool isLocked = data['isLocked'] == true;
    final bool isCurrent = data['isCurrent'] == true;
    final int levelNumber = node['level'] as int;
    
    return GestureDetector(
      onTap: () {
        if (!isLocked || isCompleted) {
          context.push('/levels/${data['id']}?num=$levelNumber');
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Завершите предыдущий уровень')),
          );
        }
      },
      child: Container(
        width: 88,
        height: 88,
        decoration: BoxDecoration(
          color: _getNodeColor(isCompleted, isCurrent, isLocked),
          borderRadius: BorderRadius.circular(20),
          border: Border.all(
            color: isCurrent ? AppColor.premium : Colors.transparent,
            width: 3,
          ),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.1),
              blurRadius: 10,
              offset: const Offset(0, 4),
            ),
            if (isCurrent)
              BoxShadow(
                color: AppColor.premium.withOpacity(0.4),
                blurRadius: 20,
                spreadRadius: 2,
              ),
          ],
        ),
        child: Center(
          child: isLocked && !isCompleted
              ? Icon(Icons.lock, color: Colors.white.withOpacity(0.7), size: 32)
              : isCompleted
                  ? const Icon(Icons.check, color: Colors.white, size: 36)
                  : Text(
                      levelNumber.toString(),
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 28,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
        ),
      ),
    );
  }
  
  Color _getNodeColor(bool isCompleted, bool isCurrent, bool isLocked) {
    if (isCompleted) return AppColor.success;
    if (isCurrent) return AppColor.info;
    if (isLocked) return Colors.grey.shade400;
    return AppColor.info.withOpacity(0.7);
  }
}

// Класс для хранения позиции в сетке
class GridPosition {
  final int column; // 0 = лево, 1 = центр, 2 = право
  final int row;    // 0 = низ, увеличивается вверх
  
  GridPosition(this.column, this.row);
}

// CustomPainter для рисования дорожек с плавными поворотами
class ZigzagPathPainter extends CustomPainter {
  final List<Offset> nodeOffsets;
  final List<dynamic> levelNodes;
  
  ZigzagPathPainter({
    required this.nodeOffsets,
    required this.levelNodes,
  });
  
  @override
  void paint(Canvas canvas, Size size) {
    if (nodeOffsets.length < 2) return;
    
    for (int i = 0; i < nodeOffsets.length - 1; i++) {
      final start = nodeOffsets[i];
      final end = nodeOffsets[i + 1];
      
      final node = levelNodes[i];
      final data = node['data'] as Map<String, dynamic>;
      final bool isCompleted = data['isCompleted'] == true;
      
      final paint = Paint()
        ..color = isCompleted 
            ? AppColor.success.withOpacity(0.6)
            : Colors.grey.withOpacity(0.3)
        ..strokeWidth = 6
        ..style = PaintingStyle.stroke
        ..strokeCap = StrokeCap.round;
      
      // Рисуем путь с закругленными углами
      _drawRoundedPath(canvas, start, end, paint);
    }
  }
  
  void _drawRoundedPath(Canvas canvas, Offset start, Offset end, Paint paint) {
    final path = Path();
    path.moveTo(start.dx, start.dy);
    
    final dx = end.dx - start.dx;
    final dy = end.dy - start.dy;
    
    // Радиус закругления
    const double radius = 30.0;
    
    if (dx.abs() < 10) {
      // Вертикальная линия
      path.lineTo(end.dx, end.dy);
    } else if (dy.abs() < 10) {
      // Горизонтальная линия
      path.lineTo(end.dx, end.dy);
    } else {
      // L-образное соединение с закруглением
      if (dy > 0) {
        // Движение вверх
        final cornerY = end.dy - radius;
        final cornerX = dx > 0 ? end.dx - radius : end.dx + radius;
        
        path.lineTo(start.dx, cornerY);
        path.quadraticBezierTo(
          start.dx, end.dy,
          cornerX, end.dy,
        );
        path.lineTo(end.dx, end.dy);
      } else {
        // Движение вниз
        final cornerY = end.dy + radius;
        final cornerX = dx > 0 ? start.dx + radius : start.dx - radius;
        
        path.lineTo(cornerX, start.dy);
        path.quadraticBezierTo(
          end.dx, start.dy,
          end.dx, cornerY,
        );
        path.lineTo(end.dx, end.dy);
      }
    }
    
    canvas.drawPath(path, paint);
  }
  
  @override
  bool shouldRepaint(ZigzagPathPainter oldDelegate) {
    return oldDelegate.nodeOffsets != nodeOffsets ||
           oldDelegate.levelNodes != levelNodes;
  }
}