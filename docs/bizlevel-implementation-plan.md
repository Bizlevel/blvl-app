# Детальный план реализации BizLevel v2.0

## Этап 1: Настройка окружения и зависимостей

### Задача 1.1: Обновление зависимостей проекта
Файлы: pubspec.yaml, pubspec.lock
Зависимости: нет
Компоненты: весь проект

Что делать:
1. Открыть pubspec.yaml
2. Удалить строку с carousel_slider из dependencies
3. Добавить новые зависимости в секцию dependencies:
   - flutter_riverpod: ^2.4.0
   - supabase_flutter: ^2.3.0
   - dio: ^5.4.0
   - video_player: ^2.8.1
   - chewie: ^1.7.0
   - flutter_cache_manager: ^3.3.0
   - flutter_animate: ^4.3.0
   - url_launcher: ^6.2.2
   - sentry_flutter: ^7.16.0
   - freezed_annotation: ^2.4.1  # модели

4. Добавить dev_dependencies:
   - build_runner: ^2.4.8
   - freezed: ^2.4.1
   - json_serializable: ^6.7.1

5. Запустить flutter pub get && flutter pub run build_runner build --delete-conflicting-outputs
6. Инициализировать Sentry (SentryFlutter.init) в main.dart
7. Убедиться что pubspec.lock обновился без ошибок, генерация моделей прошла

Почему это важно:
Новые зависимости обеспечат функционал для авторизации (Supabase), управления состоянием (Riverpod), видео плеера (better_player) и интеграции с OpenAI (dio).

Проверка результата:
Команда flutter pub get завершается успешно, приложение компилируется без ошибок зависимостей.

### Задача 1.2: Создание базовой структуры папок
Файлы: создание новых директорий
Зависимости: 1.1
Компоненты: структура проекта

Что делать:
1. Создать папку lib/models/
2. Создать папку lib/services/
3. Создать папку lib/providers/
4. Создать папку lib/screens/auth/
5. Создать папку assets/images/onboarding/
6. Добавить путь к images в pubspec.yaml в секцию assets

Почему это важно:
Новая структура разделяет логику (services), данные (models), управление состоянием (providers) и UI (screens), что обеспечит чистую архитектуру.

Проверка результата:
Все папки созданы, структура проекта соответствует плану модификации.

### Задача 1.3: Настройка Supabase проекта
Файлы: lib/services/supabase_service.dart, lib/main.dart
Зависимости: 1.2
Компоненты: SupabaseService

Что делать:
1. Создать аккаунт на supabase.com
2. Создать новый проект BizLevel
3. Скопировать URL и anon key из настроек
4. Создать файл lib/services/supabase_service.dart
5. Реализовать singleton класс для инициализации Supabase
6. Добавить метод initialize() с URL и ключом

Почему это важно:
Централизованный сервис для работы с Supabase обеспечит единую точку доступа к backend функциям.

Проверка результата:
SupabaseService создан, проект Supabase настроен, есть URL и ключ.

### Задача 1.4: Создание схемы базы данных
Файлы: SQL скрипты в Supabase
Зависимости: 1.3
Компоненты: База данных

Что делать:
1. Использовать @supabase для создания таблиц через mcp
2. Создать таблицу users согласно схеме
3. Создать таблицу levels
4. Создать таблицу lessons
5. Создать таблицу user_progress
6. Создать таблицу leo_chats
7. Создать таблицу leo_messages (отдельно, сообщения в каждой строке)
8. Создать таблицу payments
9. Настроить RLS политики для каждой таблицы (leo_messages включительно)

Почему это важно:
База данных - фундамент приложения. RLS политики обеспечат безопасность данных на уровне БД.

Проверка результата:
Все таблицы созданы в Supabase Dashboard, RLS включен и политики работают.

### Задача 1.5: Тестирование базовой инфраструктуры
Файлы: test/infrastructure_test.dart
Зависимости: 1.1-1.4
Компоненты: SupabaseService, база данных

Что делать:
1. Создать тестовый файл
2. Протестировать подключение к Supabase
3. Проверить создание тестового пользователя
4. Проверить чтение данных из levels
5. Убедиться что RLS работает корректно

Почему это важно:
Раннее выявление проблем с инфраструктурой сэкономит время в дальнейшем.

Проверка результата:
Все тесты проходят, подключение к Supabase работает, RLS политики функционируют.

## Этап 2: Базовая инфраструктура приложения

### Задача 2.1: Интеграция Riverpod в main.dart
Файлы: lib/main.dart
Зависимости: 1.5
Компоненты: MyApp, ProviderScope

Что делать:
1. Импортировать flutter_riverpod
2. Обернуть MyApp в ProviderScope
3. Добавить вызов SupabaseService.initialize() в main()
4. Сделать main() асинхронной функцией
5. Добавить WidgetsFlutterBinding.ensureInitialized()

Почему это важно:
ProviderScope обеспечит работу Riverpod во всем приложении, инициализация Supabase нужна до запуска UI.

Проверка результата:
Приложение запускается, Riverpod работает, Supabase инициализирован.

### Задача 2.2: Создание базовых моделей данных
Файлы: lib/models/user_model.dart, lib/models/level_model.dart, lib/models/lesson_model.dart
Зависимости: Задача 2.1
Компоненты: UserModel, LevelModel, LessonModel

Что делать:
1. Создать UserModel с полями из схемы БД
2. Добавить методы fromJson/toJson
3. Создать LevelModel с полями из схемы
4. Создать LessonModel с полями из схемы
5. Добавить методы сериализации для всех моделей

Почему это важно:
Типизированные модели обеспечат безопасность типов и упростят работу с данными из Supabase.

Проверка результата:
Модели созданы, методы сериализации работают корректно с тестовыми данными.

### Задача 2.3: Создание AuthService
Файлы: lib/services/auth_service.dart
Зависимости: Задача 2.2
Компоненты: AuthService

Что делать:
1. Создать класс AuthService
2. Реализовать метод signIn(email, password)
3. Реализовать метод signUp(email, password)
4. Реализовать метод signOut()
5. Добавить метод getCurrentUser()
6. Добавить обработку ошибок для каждого метода

Почему это важно:
Централизованный сервис авторизации упростит управление пользовательской сессией.

Проверка результата:
Методы авторизации работают с тестовыми данными, ошибки обрабатываются корректно.

### Задача 2.4: Создание базовых провайдеров
Файлы: lib/providers/auth_provider.dart
Зависимости: Задача 2.3
Компоненты: authStateProvider, currentUserProvider

Что делать:
1. Создать authStateProvider как StreamProvider
2. Слушать изменения auth state от Supabase
3. Создать currentUserProvider как FutureProvider
4. Загружать данные пользователя из таблицы users
5. Добавить обработку null состояний

Почему это важно:
Провайдеры обеспечат реактивное управление состоянием авторизации во всем приложении.

Проверка результата:
Провайдеры корректно отслеживают состояние авторизации и данные пользователя.

### Задача 2.5: Тестирование базовой инфраструктуры
Файлы: test/infrastructure_integration_test.dart
Зависимости: Задача 2.1, Задача 2.2, Задача 2.3, Задача 2.4
Компоненты: Все компоненты этапа

Что делать:
1. Протестировать работу Riverpod провайдеров
2. Проверить сериализацию моделей
3. Протестировать AuthService методы
4. Убедиться в корректной обработке ошибок
5. Проверить интеграцию всех компонентов

Почему это важно:
Интеграционное тестирование выявит проблемы взаимодействия компонентов.

Проверка результата:
Все тесты проходят, инфраструктура готова для построения UI.

## Этап 3: Авторизация и онбординг

### Задача 3.1: Создание экрана логина
Файлы: lib/screens/auth/login_screen.dart, lib/main.dart
Зависимости: Задача 2.5
Компоненты: LoginScreen, CustomTextBox, CustomImage

Что делать:
1. Создать LoginScreen как ConsumerStatefulWidget
2. Использовать существующие CustomTextBox для email и пароля
3. Добавить логотип через CustomImage
4. Реализовать обработку формы через AuthService
5. Добавить навигацию на экран регистрации
6. Обновить main.dart для проверки авторизации

Почему это важно:
Экран входа - первая точка контакта пользователя с приложением, важно использовать существующие компоненты.

Проверка результата:
Экран логина отображается, форма работает, навигация функционирует.

### Задача 3.2: Создание экрана регистрации
Файлы: lib/screens/auth/register_screen.dart
Зависимости: Задача 3.1
Компоненты: RegisterScreen, CustomTextBox

Что делать:
1. Создать RegisterScreen аналогично LoginScreen
2. Добавить поля email, пароль, подтверждение пароля
3. Реализовать валидацию паролей
4. После успешной регистрации направлять на онбординг
5. Добавить обработку ошибок регистрации

Почему это важно:
Регистрация должна быть простой и понятной, с четкой обратной связью об ошибках.

Проверка результата:
Регистрация работает, пользователь создается в Supabase, переход на онбординг.

### Задача 3.3: Создание первого экрана онбординга
Файлы: lib/screens/auth/onboarding_screens.dart
Зависимости: Задача 3.2
Компоненты: OnboardingProfileScreen, CustomTextBox

Что делать:
1. Создать OnboardingProfileScreen
2. Добавить поля: имя, о себе, цель обучения
3. Использовать существующие CustomTextBox
4. Сохранять данные в профиль пользователя
5. Добавить кнопку "Далее" для перехода

Почему это важно:
Персонализация важна для работы AI-ментора Leo, эти данные будут использоваться в контексте.

Проверка результата:
Форма заполняется, данные сохраняются в таблице users.

### Задача 3.4: Создание второго экрана онбординга с видео
Файлы: lib/screens/auth/onboarding_video_screen.dart
Зависимости: Задача 3.3
Компоненты: OnboardingVideoScreen, video_player + chewie

Что делать:
1. Создать OnboardingVideoScreen
2. Интегрировать video_player + chewie для показа видео (добавить кэширование) (само видео будет храниться в vimeo)
3. Настроить автовоспроизведение
4. Добавить кнопку "Начать" внизу
5. Добавить "Пропустить" через 5 секунд
6. После завершения переходить на RootApp

Почему это важно:
Видео-инструкция поможет пользователю понять концепцию платформы.

Проверка результата:
Видео воспроизводится, кнопки работают, переход на главный экран.

### Задача 3.5: Тестирование флоу авторизации
Файлы: test/auth_flow_test.dart
Зависимости: Задача 3.1, Задача 3.2, Задача 3.3, Задача 3.4
Компоненты: Все экраны авторизации

Что делать:
1. Протестировать полный флоу регистрации
2. Проверить сохранение данных онбординга
3. Протестировать вход существующего пользователя
4. Проверить обработку ошибок
5. Убедиться в корректных переходах

Почему это важно:
Авторизация - критически важный функционал, должен работать безупречно.

Проверка результата:
Все сценарии авторизации работают корректно.

## Этап 4: Система уровней и уроков

### Задача 4.1: Трансформация home.dart в levels_map_screen.dart
Файлы: lib/screens/home.dart → lib/screens/levels_map_screen.dart
Зависимости: Задача 3.5
Компоненты: HomePage → LevelsMapScreen

Что делать:
1. Переименовать файл и класс
2. Удалить CarouselSlider и связанный код
3. Удалить горизонтальный список категорий
4. Удалить секцию Recommended
5. Изменить на ConsumerWidget
6. Оставить структуру CustomScrollView

Почему это важно:
Максимальное использование существующего кода ускорит разработку и сохранит привычный UX.

Проверка результата:
Экран отображается без удаленных компонентов, структура сохранена.

### Задача 4.2: Создание LevelCard из FeatureItem
Файлы: lib/widgets/feature_item.dart → lib/widgets/level_card.dart
Зависимости: Задача 4.1
Компоненты: FeatureItem → LevelCard

Что делать:
1. Скопировать feature_item.dart в level_card.dart
2. Переименовать класс в LevelCard
3. Заменить отображение цены на номер уровня
4. Изменить session/duration на количество уроков
5. Добавить логику отображения замка для платных
6. Добавить серый оверлей для заблокированных

Почему это важно:
Переиспользование существующего компонента сохранит единообразный дизайн.

Проверка результата:
LevelCard отображается корректно, замки показываются для платных уровней.

### Задача 4.3: Интеграция данных уровней через провайдер
Файлы: lib/providers/levels_provider.dart, lib/screens/levels_map_screen.dart
Зависимости: Задача 4.2
Компоненты: levelsProvider, LevelsMapScreen

Что делать:
1. Создать levelsProvider как FutureProvider
2. Загружать уровни из Supabase
3. Обновить LevelsMapScreen для использования провайдера
4. Добавить обработку состояний loading/error
5. Отображать уровни через ListView с LevelCard

Почему это важно:
Реактивная загрузка данных обеспечит актуальность информации.

Проверка результата:
Уровни загружаются из БД и отображаются в списке.

### Задача 4.4: Создание экрана деталей уровня
Файлы: lib/screens/level_detail_screen.dart
Зависимости: Задача 4.3
Компоненты: LevelDetailScreen

Что делать:
1. Создать LevelDetailScreen
2. Принимать levelId как параметр
3. Загружать уроки через lessonsProvider
4. Отображать вертикальный список уроков
5. Добавить кнопку завершения уровня внизу
6. Реализовать навигацию с LevelCard

Почему это важно:
Экран уровня - основное место обучения пользователя.

Проверка результата:
Экран открывается при клике на уровень, уроки отображаются.

### Задача 4.5: Создание виджетов урока и теста
Файлы: lib/widgets/lesson_widget.dart, lib/widgets/quiz_widget.dart
Зависимости: Задача 4.4
Компоненты: LessonWidget, QuizWidget

Что делать:
1. Создать LessonWidget с video_player + chewie (и offline-кэш)
2. Настроить соотношение 9:16 для видео
3. Создать QuizWidget с RadioListTile
4. Реализовать локальную проверку ответов
5. Добавить блокировку прогресса до просмотра
6. Интегрировать в LevelDetailScreen

Почему это важно:
Уроки и тесты - ключевой образовательный контент платформы.

Проверка результата:
Видео воспроизводятся, тесты проверяются, прогресс блокируется корректно.

### Задача 4.6: Тестирование системы уровней
Файлы: test/levels_system_test.dart
Зависимости: Задача 4.1, Задача 4.2, Задача 4.3, Задача 4.4, Задача 4.5
Компоненты: Вся система уровней

Что делать:
1. Протестировать загрузку уровней
2. Проверить отображение замков
3. Протестировать прохождение урока
4. Проверить сохранение прогресса
5. Убедиться в последовательном прохождении

Почему это важно:
Система уровней - core функционал, должна работать без сбоев.

Проверка результата:
Все тесты проходят, система уровней функционирует.

## Этап 5: Интеграция Leo AI

### Задача 5.1: Настройка Edge Function для Leo
Файлы: supabase/functions/leo-chat/index.ts
Зависимости: 4.6
Компоненты: Edge Function

Что делать:
1. Создать Edge Function в Supabase
2. Настроить интеграцию с OpenAI API
3. Добавить контекст пользователя в промпт
4. Реализовать подсчет токенов
5. Настроить CORS для мобильного приложения

Почему это важно:
Edge Function обеспечит безопасный доступ к OpenAI без раскрытия ключей.

Проверка результата:
Function деплоится, отвечает на тестовые запросы.

### Задача 5.2: Создание LeoService
Файлы: lib/services/leo_service.dart
Зависимости: 5.1
Компоненты: LeoService

Что делать:
1. Создать класс LeoService
2. Реализовать sendMessage() через dio
3. Добавить checkMessageLimit()
4. Реализовать decrementMessageCount()
5. Добавить saveConversation()
6. Обработать все возможные ошибки

Почему это важно:
Централизованный сервис упростит работу с AI и контроль лимитов.

Проверка результата:
Сервис отправляет сообщения и получает ответы от Leo.

### Задача 5.3: Трансформация chat.dart в leo_chat_screen.dart
Файлы: lib/screens/chat.dart → lib/screens/leo_chat_screen.dart
Зависимости: 5.2
Компоненты: ChatPage → LeoChatScreen

Что делать:
1. Переименовать файл и класс
2. Удалить CustomTextBox для поиска
3. Изменить логику отображения на историю с Leo
4. Использовать существующий ChatItem
5. Добавить кнопку "Новый диалог"
6. Показывать счетчик сообщений

Почему это важно:
Использование существующих компонентов ускорит разработку.

Проверка результата:
Экран показывает историю диалогов с Leo.

### Задача 5.4: Создание экрана диалога с Leo
Файлы: lib/screens/leo_dialog_screen.dart, lib/widgets/leo_message_bubble.dart
Зависимости: 5.3
Компоненты: LeoDialogScreen, LeoMessageBubble

Что делать:
1. Создать LeoDialogScreen
2. Использовать ListView для сообщений
3. Создать LeoMessageBubble для отображения
4. Использовать CustomTextBox для ввода
5. Добавить индикатор набора текста
6. Реализовать отправку через LeoService

Почему это важно:
Диалог с AI - ключевая особенность платформы для закрепления знаний.

Проверка результата:
Диалог работает, сообщения отправляются и отображаются.

### Задача 5.5: Тестирование Leo AI интеграции
Файлы: test/leo_integration_test.dart
Зависимости: 5.1-5.4
Компоненты: Вся система Leo

Что делать:
1. Протестировать отправку сообщений
2. Проверить подсчет лимитов
3. Протестировать сохранение истории
4. Проверить обработку ошибок
5. Убедиться в корректном отображении

Почему это важно:
AI функционал должен работать стабильно и предсказуемо.

Проверка результата:
Leo отвечает на сообщения, лимиты работают, история сохраняется.

## Этап 6: Профиль и монетизация

### Задача 6.1: Трансформация account.dart в profile_screen.dart
Файлы: lib/screens/account.dart → lib/screens/profile_screen.dart
Зависимости: Задача 5.5
Компоненты: AccountPage → ProfileScreen

Что делать:
1. Переименовать файл и класс
2. Изменить отображение статистики
3. Показывать уровень вместо courses
4. Показывать сообщения Leo вместо hours
5. Добавить секцию артефактов
6. Добавить кнопку Premium если не подписан

Почему это важно:
Профиль должен отражать прогресс и мотивировать к покупке подписки.

Проверка результата:
Профиль отображает актуальную статистику пользователя.

### Задача 6.2: Создание системы артефактов
Файлы: lib/widgets/artifact_card.dart, lib/screens/profile_screen.dart
Зависимости: Задача 6.1
Компоненты: ArtifactCard, ProfileScreen

Что делать:
1. Адаптировать recommend_item.dart в artifact_card.dart
2. Добавить логику скачивания через url_launcher
3. Интегрировать список артефактов в профиль
4. Показывать только доступные артефакты
5. Добавить signed URLs для скачивания

Почему это важно:
Артефакты - дополнительная ценность для пользователей.

Проверка результата:
Артефакты отображаются и скачиваются корректно.

### Задача 6.3: Создание экрана оплаты
Файлы: lib/screens/payment_screen.dart
Зависимости: Задача 6.2
Компоненты: PaymentScreen

Что делать:
1. Создать экран с инструкцией оплаты в виде мока

Почему это важно:
Простая и понятная оплата критична для монетизации.


### Задача 6.4: Обновление навигации в RootApp
Файлы: lib/screens/root_app.dart
Зависимости: 6.3
Компоненты: RootApp, BottomBarItem

Что делать:
1. Изменить на ConsumerWidget
2. Оставить только 3 таба
3. Обновить иконки и страницы
4. Подключить новые экраны
5. Сохранить анимации переходов

Почему это важно:
Навигация должна быть простой и интуитивной.

Проверка результата:
Навигация работает между тремя основными экранами.

### Задача 6.5: Тестирование профиля и монетизации
Файлы: test/profile_monetization_test.dart
Зависимости: 6.1-6.4
Компоненты: Профиль и платежи

Что делать:
1. Протестировать отображение статистики
2. Проверить доступ к артефактам
3. Протестировать флоу оплаты
4. Проверить обновление статуса Premium
5. Убедиться в корректной навигации

Почему это важно:
Монетизация должна работать без сбоев.

Проверка результата:
Все функции профиля и оплаты работают корректно.

## Этап 7: Финализация и оптимизация

### Задача 7.1: Добавление начальных данных
Файлы: SQL скрипты, Supabase Dashboard
Зависимости: 6.5
Компоненты: База данных

Что делать:
1. Вставить 10 уровней в таблицу levels
2. Добавить по 3-5 уроков на уровень
3. Загрузить артефакты в Storage
4. Проверить доступность данных
5. Протестировать RLS политики

Почему это важно:
Без контента приложение не имеет ценности.

Проверка результата:
Все уровни и уроки доступны в приложении.

### Задача 7.2: Оптимизация производительности
Файлы: все экраны и виджеты
Зависимости: 7.1
Компоненты: UI компоненты

Что делать:
1. Добавить const где возможно
2. Оптимизировать rebuild виджетов
3. Настроить кэширование изображений
4. Оптимизировать видео загрузку
5. Проверить память и CPU usage

Почему это важно:
Плавная работа критична для удержания пользователей.

Проверка результата:
Приложение работает плавно на средних устройствах.

### Задача 7.3: Обработка ошибок и edge cases
Файлы: все сервисы и экраны
Зависимости: 7.2
Компоненты: Все компоненты

Что делать:
1. Добавить обработку отсутствия интернета
2. Обработать истечение сессии
3. Добавить retry логику для запросов
4. Показывать понятные сообщения об ошибках
5. Логировать критические ошибки

Почему это важно:
Graceful degradation улучшит пользовательский опыт.

Проверка результата:
Приложение корректно обрабатывает все ошибки.

### Задача 7.4: Подготовка к релизу
Файлы: android/app/build.gradle, pubspec.yaml
Зависимости: 7.3
Компоненты: Конфигурация сборки

Что делать:
1. Обновить версию в pubspec.yaml
2. Настроить подпись APK
3. Оптимизировать размер приложения
4. Проверить permissions
5. Собрать release APK

Почему это важно:
Правильная сборка обеспечит установку на устройства пользователей.

Проверка результата:
APK собирается и устанавливается на тестовые устройства.

### Задача 7.5: Финальное тестирование
Файлы: test/integration_test.dart
Зависимости: 7.1-7.4
Компоненты: Все приложение

Что делать:
1. Пройти полный user journey
2. Протестировать на разных устройствах
3. Проверить работу без интернета
4. Протестировать восстановление сессии
5. Убедиться в стабильности

Почему это важно:
Финальная проверка гарантирует готовность к запуску.

Проверка результата:
Приложение работает стабильно во всех сценариях использования.