# Этап 29: Бот Алекс — трекер цели (минимальные изменения)

### Задача 29.1: База данных — маркировка чатов по боту
- Файлы: `supabase/migrations/YYYYMMDD_add_leo_chats_bot.sql`
- Что сделать:
  1) Добавить колонку `bot text not null default 'leo' check (bot in ('leo','alex'))` в `public.leo_chats`.
  2) Бэкфилл существующих строк: установить `bot = 'leo'` (в рамках `DEFAULT` значений это не требуется, но зафиксировать явно).
  3) Индекс производительности для списков: `create index if not exists idx_leo_chats_user_bot_updated on public.leo_chats(user_id, bot, updated_at desc);`
  4) RLS/политики не менять (привязка по `user_id` сохраняется). Триггеры и счётчики сообщений не трогаем.
- Проверка:
  - Применить миграцию через supabase-mcp (apply_migration), затем `list_tables` и выборка `select bot,count(*) from leo_chats group by 1`.

### Задача 29.2: Edge Function — единая `leo-chat` с режимом `bot`
- Файл: `supabase/functions/leo-chat/index.ts`
- Что сделать (без создания новой функции):
  1) Принимать параметр `bot` в теле запроса: `'leo' | 'alex'` (по умолчанию `'leo'`).
  2) Если `bot==='alex'`:
     - Сформировать отдельный системный промпт «Алекс — трекер цели» с фокусом на кристаллизацию цели и поддержку в спринтах (короткие, конкретные ответы; без таблиц и «могу помочь…» — правила как у Лео, тон и приоритеты иные).
     - Дополнительно выбирать данные для контекста:
       - `users`: `name, goal, business_area, experience_level, current_level` (если есть)
       - `core_goals`: последняя версия (version, goal_text, version_data)
       - `weekly_progress`: последняя запись или текущий спринт
       - `reminder_checks`: записи по текущему дню/неделе (минимум — текущий день)
       - `motivational_quotes`: активная цитата дня
       - `user_memories`: последние 3–5
       - `leo_chats.summary`: последние 2–3 свёртки, фильтр `bot='alex'`
     - Встроенный RAG: вызывать `rpc('match_documents', ...)` как у Лео; при наличии `levelContext` — передавать `metadata_filter`. Модель/температура/лимиты — те же ENV, что у Лео.
  3) Если `bot!=='alex'` — оставить текущее поведение Лео без изменений (режим трекера у Лео отключается на клиенте; серверная ветка Лео соответствует состоянию до этапа 28).
- Проверка:
  - Локальный вызов `leo-chat` с `bot='alex'` возвращает ответ с включёнными секциями «Цель/Спринт/Напоминания/Память/Итоги обсуждений/RAG».

### Задача 29.3: Клиент — параметр `bot` в сервисе и создании чатов
- Файлы: `lib/services/leo_service.dart`, места вызова `saveConversation`/`sendMessageWithRAG`
- Что сделать:
  1) В `sendMessageWithRAG` добавить параметр `String bot = 'leo'` и передавать его в тело POST `/leo-chat`.
  2) В `saveConversation(...)` добавить параметр `String bot = 'leo'` и при создании новой записи в `leo_chats` проставлять `{'bot': bot}`.
  3) Обратная совместимость: существующие вызовы не меняем (дефолт `'leo'`).

### Задача 29.4: UI — интеграция Алекса в «Цель» и «Чат»
- Файлы: `lib/widgets/floating_chat_bubble.dart`, `lib/screens/leo_dialog_screen.dart`, `lib/screens/leo_chat_screen.dart`, `lib/screens/goal_screen.dart`
- Что сделать:
  1) `LeoDialogScreen`: добавить параметр `bot = 'leo'`; заголовок AppBar менять на «Диалог с Алекс», если `bot==='alex'`; прокинуть `bot` в `LeoService` методы.
  2) `FloatingChatBubble`: добавить параметр `bot` и текст кнопки; на странице «Цель» использовать `bot='alex'` и лейбл «Обсудить с Алекс»; по умолчанию — Лео.
  3) `LeoChatScreen`: добавить переключатель вкладок «Лео»/«Алекс» (фильтр списка по `leo_chats.bot`), FAB: «Новый диалог с Лео» и опция «Новый диалог с Алекс».
  4) В уровнях и на общей странице «Чат» по умолчанию остаётся Лео; на странице «Цель» — автоматически открывать Алекса.

### Задача 29.5: Контекст и промпт Алекса
- Файл: `supabase/functions/leo-chat/index.ts`
- Что сделать:
  - Описать блоки контекста в системном промпте для `bot='alex'`: «ДАННЫЕ ЦЕЛИ», «СПРИНТ», «НАПОМИНАНИЯ», «ЛИЧНЫЕ ЗАМЕТКИ», «ИТОГИ ПРОШЛЫХ ОБСУЖДЕНИЙ», «RAG контекст».
  - Приоритет ответов: 1) цель/метрики пользователя, 2) практические шаги на ближайший день/неделю, 3) дополнение из материалов курса (RAG), 4) краткое завершение без «предложений помощи».
  - Сохранить те же модель/параметры OpenAI (ENV), что у Лео.

### Задача 29.6: Лимиты, память и совместимость
- Что сделать:
  - Использовать те же лимиты сообщений (общие поля в `users`), отдельный бюджет для Алекса не вводить (MVP).
  - Триггер `leo-memory` оставить без изменений — «память» общая на пользователя; свёртки `leo_chats.summary` учитывают `bot` при выборке в контексте Алекса.
  - Поведение Лео вернуть к роли «ментор» (без трекер‑логики) — реализуется тем, что клиент перестаёт передавать «трекинговый» контекст для `bot='leo'`.

### Задача 29.7: Тесты
- Файлы: `test/services/leo_service_unit_test.dart`, `test/screens/leo_chat_screen_test.dart`, `test/goal_alex_flow_test.dart`
- Что проверить:
  1) `LeoService.sendMessageWithRAG` передаёт `bot` в тело запроса; `saveConversation` проставляет `bot` в `leo_chats`.
  2) Фильтрация чатов по `bot` и создание нового диалога с Алекс из `LeoChatScreen`.
  3) Открытие чата с Алекс с страницы «Цель» (через `FloatingChatBubble`), наличие контекста цели/спринта в промпте.
  4) Backward‑compatibility: диалоги Лео продолжают работать как прежде.
- Подсказка в UI (tooltip/баннер) при первом открытии «Цели»: «Диалог с Алекс помогает кристаллизовать цель и поддерживает вас 28 дней».

### Задача 29.8: Аудит схемы и индексов для Leo/Alex и RAG
- Инструменты: supabase-mcp (`list_tables`, `execute_sql`).
- Что сделать:
  1) Проверить структуру таблиц: `users`, `leo_chats` (включая `bot`, `summary`, `last_topics`), `leo_messages`, `user_memories`, `documents` (наличие `embedding vector` и `metadata jsonb`), `core_goals`, `weekly_progress`, `reminder_checks`, `motivational_quotes`.
  2) Проверить индексы производительности: 
     - `idx_leo_chats_user_bot_updated` на `(user_id, bot, updated_at desc)`;
     - ANN/IVFFLAT/HNSW индекс на `documents(embedding)`;
     - GIN индекс на `documents(metadata)`;
     - индексы на навыках: `idx_levels_skill_id`, `idx_user_skills_skill`.
  3) Проверить триггеры на `leo_messages` (AFTER INSERT ассистента → вызов памяти) и отсутствие дубликатов `public.call_leo_memory(...)`.
  4) Подтвердить наличие перегрузки RPC `match_documents(vector, double precision, integer, jsonb)`.
- Критерии приёмки: все объекты существуют; индексы присутствуют; перегрузка RPC с `jsonb` доступна; нет дублирующих сигнатур `call_leo_memory`.

### Задача 29.9: Конфигурация секретов и GUC для edge‑функций
- Инструменты: Supabase Studio (Edge Functions Settings), supabase-mcp (`execute_sql`).
- Что сделать:
  1) Установить БД‑GUC: `app.supabase_url`, `app.service_role_key` (без коммитов ключей в репозиторий).
  2) Для edge‑функции `leo-memory` задать секрет `CRON_SECRET` и выполнить redeploy.
  3) Для `leo-chat` убедиться, что внешние ключи (если используются) берутся из ENV/секретов, а не из кода.
- Критерии приёмки: `current_setting('app.supabase_url', true)` и `current_setting('app.service_role_key', true)` возвращают непустые значения; `leo-memory` читает `CRON_SECRET`; функции успешно деплоятся.

### Задача 29.10: Smoke‑проверка пайплайна памяти
- Инструменты: supabase-mcp (`execute_sql`).
- Что сделать:
  1) Выполнить ручной вызов `public.call_leo_memory(...)` на последнем ассистентском сообщении (как в `docs/1.md`).
  2) Проверить, что появилась запись в `leo_messages_processed` для этого `message_id`.
  3) Проверить обновление `leo_chats.summary` и `leo_chats.last_topics` по соответствующему `chat_id`.
- Критерии приёмки: сообщение помечено как обработанное, свёртки обновились без ошибок.

### Задача 29.11: Smoke‑проверка RAG с metadata_filter
- Инструменты: supabase-mcp (`execute_sql`), логи edge‑функции `leo-chat`.
- Что сделать:
  1) Выполнить SQL‑запрос к `match_documents` с `metadata_filter` по уровню (например, `{"level_id":1}`) и убедиться, что есть релевантные совпадения.
  2) Отправить тестовый запрос в `leo-chat` с `levelContext` и проверить по логам, что фильтр применяется и ошибок RAG нет.
- Критерии приёмки: SQL возвращает результаты, логи функции фиксируют применение `metadata_filter` и отсутствие ошибок.

### Задача 29.12: Бэкфилл и индексация `documents`
- Инструменты: скрипт `scripts/upload_from_drive.py`, supabase-mcp (`execute_sql`).
- Что сделать:
  1) Проверить заполненность `documents.metadata` (`level_id`, `lesson_id`, `tags` вида "Level N"/"Lesson N"). При нехватке — выполнить бэкфилл через `documents_backfill_map` и загрузчик.
  2) Создать (если отсутствуют) индексы: ANN на `embedding` и GIN на `metadata`.
  3) Пройти advisors (performance) — убедиться в отсутствии предупреждений по этим таблицам.
- Критерии приёмки: покрытие метаданных ≥ 95%; индексы на месте; latency `match_documents` в норме; advisors без новых WARN/ERROR.

### Задача 29.13: Выравнивание RAG‑фильтра для `bot='alex'` в `leo-chat`
- Файл: `supabase/functions/leo-chat/index.ts`.
- Что сделать:
  1) Убедиться, что при наличии `levelContext` ветка `bot='alex'` передаёт `metadata_filter` в `rpc('match_documents', ...)` аналогично Лео.
  2) Добавить структурированное логирование факта применения `metadata_filter` (без утечки данных пользователя).
- Критерии приёмки: ответы Алекса включают RAG по уровню/уроку, логи подтверждают применение фильтра; поведение Лео не меняется.

### Задача 29.14: Безопасность service role и секретов
- Инструменты: ревью репозитория, CI.
- Что сделать:
  1) Исключить `service_role_key` и любые секреты из `.env` и коммитов (проверить `.gitignore`, скрипты, README).
  2) Хранить секреты только в БД‑GUC/Edge Secrets/CI Secrets. В клиенте — использовать `envOrDefine` без сервисных ключей.
  3) (Опционально) В CI добавить grep‑проверку на строки вида `service_role`/`app.service_role_key` в изменениях пул‑реквестов.
- Критерии приёмки: в репозитории отсутствуют секреты; CI/ревью проходят; Sentry/логи не содержат секретов.

### Задача 29.15: Мини‑сид данных для `bot='alex'`
- Инструменты: supabase-mcp (`execute_sql`).
- Что сделать:
  1) Вставить под тестового пользователя минимальные записи: `core_goals(v1)`, один `weekly_progress`, `reminder_checks` (текущий день), одну активную запись в `motivational_quotes`.
  2) Отправить вопрос в `leo-chat` с `bot='alex'` и убедиться, что ответ содержит секции «Цель/Спринт/Напоминания/Цитата».
- Критерии приёмки: Алекс отвечает предметно, без RAG‑регрессий.

### Задача 29.16: Наблюдаемость (Sentry и логи edge)
- Инструменты: sentry-mcp, логи Supabase Edge.
- Что сделать:
  1) Проверить отсутствие критичных нерешённых ошибок за 24 часа (скрипт `scripts/sentry_check.sh`).
  2) Убедиться, что edge‑функции логируют ключевые этапы (применение фильтра, обращение к памяти) без PII.
- Критерии приёмки: критичных ошибок нет; логи информативны и безопасны.

# Этап 30: Правки по UX/UI

### Задача 30.1: Уровень 0 — форма профиля в режиме «просмотр/редактирование»
- Цель: после сохранения профиля («Перейти на Уровень 1») поля остаются заполненными и переходят в read-only. В правом верхнем углу блока появляется серая иконка «Редактировать», по нажатию поля становятся активными.
- Файлы: `lib/screens/level_detail_screen.dart` (+минимальные правки в `CustomTextBox`, если потребуется только проп `readOnly`).
- Что сделать:
  1) Поднять состояние формы в `_LevelDetailScreenState`: контроллеры `profileNameCtrl/profileAboutCtrl/profileGoalCtrl`, `selectedAvatarId`, флаг `isProfileEditing` (по умолчанию `true` до первого сохранения), `profileInitialized`.
  2) При первом получении данных `currentUserProvider` заполнить контроллеры и `selectedAvatarId`, затем `profileInitialized = true`.
  3) Передать контроллеры/`selectedAvatarId`/`isProfileEditing` в `_ProfileFormBlock` через конструктор; внутри блока убрать создание собственных контроллеров.
  4) В UI формы использовать `CustomTextBox(readOnly: !isProfileEditing)` и добавить `IconButton(Icons.edit, color: Colors.grey)` в правом верхнем углу блока. По нажатию переключать `isProfileEditing = true`.
  5) После успешного `AuthService.updateProfile(...)` ставить `isProfileEditing = false` и `_profileSaved = true` (для логики «Завершить уровень»). Значения в полях остаются от контроллеров — повторный заход отображает их сразу.
- Критерии приёмки:
  - После нажатия «Перейти на Уровень 1» при повторном открытии уровня 0 поля предзаполнены из профиля и заблокированы для редактирования.
  - Иконка «Редактировать» присутствует; после нажатия поля становятся активными, повторное сохранение обновляет профиль.
  - Никаких изменений схемы БД; используются существующие `updateProfile` и провайдеры.

### Задача 30.2: Страница «Цель» — read-only после сохранения + иконка «Редактировать»
- Цель: по умолчанию существующая последняя версия цели отображается в режиме просмотра; поля становятся редактируемыми только по нажатию на серую иконку «Редактировать». Автосохранение отключено в режиме просмотра.
- Файлы: `lib/screens/goal_screen.dart`.
- Что сделать:
  1) Добавить флаг `_isEditing`. Инициализация: если версия отсутствует — `_isEditing = true`; если версия существует — `_isEditing = false` (только последняя версия доступна для редактирования).
  2) При переключении версии устанавливать `_isEditing = (выбранная версия == последняя)`.
  3) Во все `CustomTextBox` передать `readOnly: !_isEditing`. Кнопку «Сохранить» блокировать, если `_isEditing == false`.
  4) В заголовке «Кристаллизация цели vX» добавить `IconButton(Icons.edit, color: Colors.grey)`; клик переводит `_isEditing = true` (только для последней версии).
  5) В `_scheduleAutosave()` мгновенно выходить, если `_isEditing == false`.
  6) После успешного `_saveGoal()` — `_isEditing = false`, значения остаются в контроллерах.
- Критерии приёмки:
  - При наличии сохранённой v1 (или выше) форма открывается в read-only, автосохранение не срабатывает; отображается иконка «Редактировать».
  - Нажатие иконки включает редактирование только для последней версии; после «Сохранить» форма снова read-only с актуальными значениями.
  - Поведение версий (создание следующей) не изменено. БД/репозитории остаются прежними (`core_goals`, `GoalsRepository`).

### Задача 30.3: Переименование бота «Алекс» → «Макс» (БД + Edge + клиент)
- Цель: унифицировать имя бота‑трекера везде как «Макс»/`max`.
- Файлы/инструменты: `supabase/functions/leo-chat/index.ts`, `lib/services/leo_service.dart`, `lib/screens/goal_screen.dart`, `lib/screens/leo_chat_screen.dart`, `lib/widgets/floating_chat_bubble.dart`, `lib/screens/leo_dialog_screen.dart`, supabase‑mcp (миграция).
- Что сделать:
  1) БД (через supabase‑mcp `apply_migration`):
     - `UPDATE public.leo_chats SET bot = 'max' WHERE bot = 'alex';`
     - Переопределить CHECK на колонке `leo_chats.bot` → `CHECK (bot in ('leo','max'))`.
  2) Edge Function `leo-chat`: трактовать `bot` как строку `'leo' | 'max'`; временно поддержать входящий `'alex'` как `'max'` для совместимости. Тексты промпта обновить: «Ты — Макс…».
  3) Клиент: заменить все сравнения/передачи `'alex'` → `'max'`; русские подписи «Алекс» → «Макс». В `GoalScreen` для bubble `bot: 'max'`.
- Критерии приёмки:
  - Список чатов фильтруется по `bot='leo'/'max'`, старые записи с `'alex'` видны как `'max'`.
  - Отправка сообщений с `bot='max'` работает; edge‑функция возвращает ответы без регрессий.

### Задача 30.4: Страница «Чат» — выбор бота карточками
- Цель: заменить чипы «Лео/Макс» на две большие кнопки‑карточки по центру экрана.
- Файлы: `lib/screens/leo_chat_screen.dart`, ассеты `assets/images/avatars/avatar_leo.png`, `assets/images/avatars/avatar_max.png` (уже есть).
- Что сделать:
  1) В шапке оставить счётчик сообщений для активного бота, убрать текущий заголовок аватар и имя бота
  2) Вместо `_buildBotSwitcher()` отрисовать две карточки одинакового размера:
     - Лео: аватар, «Лео AI», подпись серым «Твой бизнес‑ментор».
     - Макс: аватар `avatar_max.png`, «Макс AI», подпись серым «Твой помощник в достижении цели».
     - Активную карточку подсвечивать (обводка/фон), по нажатию — переключать `_activeBot` и перезагружать список.
- Критерии приёмки: карточки по центру, корректная подсветка активного, фильтрация чатов работает.

### Задача 30.5: FAB/баббл — «Новый чат с …» + мини‑ава
- Файлы: `lib/screens/leo_chat_screen.dart`, `lib/widgets/floating_chat_bubble.dart`.
- Что сделать:
  1) В тексте заменить «Новый диалог с …»/«Обсудить с …» → «Новый чат с Лео/Максом».
  2) Вставить слева маленький `CircleAvatar` бота (соответствующий аватар).
- Критерии приёмки: корректные подписи и аватары для обоих ботов.

### Задача 30.6: Шапка окна диалога — аватар + имя на кириллице
- Файлы: `lib/screens/leo_dialog_screen.dart`.
- Что сделать: в `AppBar.title` вместо текста «Диалог с …» отрисовать Row: аватар бота + имя «Лео»/«Макс» (кириллица), выровнять по центру, сохранить цветовую схему.
- Критерии приёмки: правильные имена/аватары по типу бота, без переломов макета на мобильном и web.

# Этап 31: Замена тестов на чат

### Задача 31.1: Анализ и подготовка данных квиза
- Цель: убедиться, что текущие данные уроков подходят для «чат‑теста» без миграций схемы.
- Что сделать:
  1) Проверить, что у всех уроков, где есть квиз, в `lessons.quiz_questions[0]` присутствуют поля `question: string`, `options: string[]` и есть соответствующий `correct_answers[0]: int`.
  2) (Опционально) Для каждого такого квиза добавить поле `script` в JSON `quiz_questions[0]` — короткая установка от имени Лео (если поле отсутствует, клиент покажет дефолтное приветствие).
- База данных: миграции не требуются; работаем с существующей структурой `lessons`.

### Задача 31.2: Клиент — новый виджет `LeoQuizWidget`
- Файлы: `lib/widgets/leo_quiz_widget.dart` (новый), `lib/screens/level_detail_screen.dart` (использование в блоке квиза).
- Что сделать:
  1) Создать виджет `LeoQuizWidget` с пропсами: `questionData`, `onCorrect`, `initiallyPassed`, `userContext`.
  2) UI: первое сообщение ассистента (из `questionData.script` или дефолт), список вариантов ответа кнопками под зоной ввода, компактная лента сообщений (1–2 сообщения), без истории.
  3) Поведение: локально проверять выбор (`selectedIndex == correctIndex`), запрашивать короткий ответ от Лео (успех/подсказка), при верном ответе — дизейблить варианты и вызывать `onCorrect(pageIndex)` для разблокировки «Далее».
  4) Поддержать `initiallyPassed: true` — сразу показывать состояние «пройдено», без возможности повторного ввода.
  5) Обработка ошибок/оффлайн: при недоступности Edge отобразить локальную заготовку ответа; «Далее» разрешать после локальной валидации верного варианта (поведение задать как дефолтное, чтобы не блокировать прогресс оффлайн).

### Задача 31.3: Клиент — сервис `LeoService.sendQuizFeedback`
- Файл: `lib/services/leo_service.dart`.
- Что сделать:
  1) Добавить метод `Future<Map<String, dynamic>> sendQuizFeedback({ required String question, required List<String> options, required int selectedIndex, required int correctIndex, required String userContext, int maxTokens = 180 })`.
  2) Вызов: POST `/leo-chat` с телом `{ mode: 'quiz', isCorrect, quiz: { question, options, selectedIndex, correctIndex }, userContext, maxTokens }`.
  3) В режиме `quiz` не выполнять `decrementMessageCount()` и не вызывать `saveConversation()` — эти сообщения не должны расходовать общий лимит и не должны создавать записи в `leo_chats/leo_messages`.
  4) Таймауты/ретраи — как в существующих методах; маппинг ошибок в `LeoFailure` и отдельное сообщение для оффлайн.
  5) Наблюдаемость: оборачивать ошибки в Sentry (`captureException`) без PII.

### Задача 31.4: Edge Function `leo-chat` — режим `mode='quiz'`
- Файл: `supabase/functions/leo-chat/index.ts`. Инструменты: supabase‑mcp для деплоя.
- Что сделать:
  1) Принимать payload с `mode: 'quiz'`, `isCorrect: boolean`, `quiz: { question, options, selectedIndex, correctIndex }`, `userContext: string`, `maxTokens?: number`.
  2) Для `mode='quiz'` отключить RAG/память/историю и любые записи в БД; ответ строить как одно короткое сообщение ассистента. Уважать `maxTokens` (по умолчанию 160–200), температуру снизить.
  3) Системный промпт на русском: краткий, без «чем ещё помочь». Ветвление по `isCorrect`: 
     - неверно — поддержка и мягкая подсказка, не раскрывая правильный вариант;
     - верно — короткое поздравление и 2–3 строки персональной применимости на основе `userContext` (`users.name/goal/about`).
  4) Логирование: структурированное, без PII.
  5) Совместимость: текущие ветки Лео/Макс без изменений; `mode='quiz'` — отдельная ветка ответа, не влияющая на обычный чат.

### Задача 31.5: Интеграция в маршрут уровня
- Файл: `lib/screens/level_detail_screen.dart`.
- Что сделать:
  1) Внутри `_QuizBlock` заменить `QuizWidget` на `LeoQuizWidget`, сохранив логику `onCorrect(index)` и `initiallyPassed`.
  2) Передавать `userContext`, собранный из `currentUserProvider` (минимум: имя, цель, о себе) в компактной строке.
  3) Никаких изменений в `_isLevelCompleted()` и прогрессе не требуется: `onCorrect(index)` по‑прежнему вызывает `markQuizPassed(index)` и `unlockNext(index)`.

### Задача 31.6: Фича‑флаг и обратная совместимость
- Файлы: `lib/screens/level_detail_screen.dart`, (опц.) `lib/utils/constant.dart`.
- Что сделать:
  1) Ввести флаг `kUseLeoQuiz` (compile‑time или константа), включающий новый виджет `LeoQuizWidget`.
  2) При `kUseLeoQuiz == false` рендерить старый `QuizWidget` — безопасное поэтапное включение.

### Задача 31.7: Тесты
- Файлы: `test/level_detail_screen_test.dart`, `test/services/leo_service_test.dart`, `test/widgets/leo_quiz_widget_test.dart`, `test/web_smoke_test.dart` (добавление сценария).
- Что проверить:
  1) Разблокировка «Далее» после верного ответа в `LeoQuizWidget` и вызова `onCorrect`.
  2) `LeoService.sendQuizFeedback` — корректный payload, заголовки, обработка сетевых ошибок.
  3) Оффлайн‑сценарий: локальное поздравление и возможность продолжить.
  4) Web‑рендер `LeoQuizWidget` с мок‑сервисом — отсутствие ошибок.

### Задача 31.8: Наблюдаемость и безопасность
- Файлы: `lib/services/leo_service.dart`, `supabase/functions/leo-chat/index.ts`.
- Что сделать:
  1) Логировать ошибки в Sentry на клиенте (без PII), в Edge — структурированные логи (без пользовательских данных).
  2) Убедиться, что режим `quiz` не изменяет лимиты сообщений пользователя и не создаёт записи в `leo_chats/leo_messages`.

### Задача 31.9: Критерии приёмки
- После просмотра видео появляется блок «чат‑тест» вместо старого квиза.
- Неверный ответ — поддержка и предложение попробовать ещё раз; «Далее» неактивна.
- Верный ответ — короткое поздравление + персональная применимость; блок фиксируется как пройденный, «Далее» активна.
- Прогресс уровня и завершение работают без изменений; БД‑миграции не нужны.
- Режим `quiz` не создаёт чатов и не тратит лимит сообщений.

### Задача 31.10: Риски и смягчение
- Оффлайн или сбой Edge — показать локальный ответ и разрешить «Далее» после верной локальной проверки.
- Перерасход токенов — жёсткий `maxTokens` и лаконичный системный промпт.
- Регрессии UI — фича‑флаг и поэтапное включение; fallback на `QuizWidget`.

### Задача 31.11: Миграция вопросов/вариантов/комментариев из `docs/archive/Вопросы для тестов.md` в Supabase
- Цель: перенести подготовленные вопросы (уровни 1–10, блоки 1–4) в БД, чтобы «чат‑тест» использовал реальные данные.
- Таблицы/схема: без изменений. Используем существующие поля в `public.lessons`:
  - `quiz_questions jsonb[]` — кладём один объект c ключами: `{ question, options, correct, script?, explanation? }`;
  - `correct_answers int[]` — массив из одного индекса `correct`.
- Маппинг:
  1) Соотнести разделы markdown по заголовкам «Уровень N» с записями `levels.number = N`.
  2) Внутри уровня привязать «Блок 1..4» к `lessons(order = 1..4)` по возрастанию `order`.
  3) Если количество уроков ≠ количеству блоков:
     - уроков больше — заполняем первые K блоков, остальные квизы оставляем пустыми;
     - уроков меньше — используем первые K блоков из markdown, остальные пропускаем (внести в TODO на дополнение уроков/контента).
  4) `options` — список вариантов (A..D) в порядке; `correct` — индекс правильного варианта (0..3) по букве; `explanation` — абзац после «Правильный ответ»; `script` — короткое вступление Лео (если нет в md — сгенерировать дефолт «Давай проверим понимание…»).
- Реализация:
  1) Написать одноразовый конвертер `scripts/quiz_md_to_json.py` (или `.dart`): парсинг md → JSON‑карта `{ level, block, question, options[], correctLetter, explanation }`.
  2) Генерировать SQL‑файл с `UPDATE public.lessons SET quiz_questions = '[{...}]'::jsonb[], correct_answers = ARRAY[<idx>] WHERE level_id = <id> AND "order" = <block>;` для каждого урока.
  3) Запустить SQL через supabase‑mcp (`execute_sql`) батчами по уровню.
- Проверка/валидация:
  1) Выборки: `select level_id, "order", quiz_questions, correct_answers from public.lessons where level_id in (select id from levels where number between 1 and 10) order by level_id, "order";`
  2) Ручной просмотр 2–3 уровней в клиенте: отображается вступительное сообщение, варианты присутствуют, верный индекс работает.
  3) Локальный тест «прогресс» — `onCorrect` срабатывает, «Далее» активна.
- Критерии приёмки:
  - Во всех уровнях 1–10 у соответствующих уроков заполнены `quiz_questions[0]` и `correct_answers[0]`.
  - Объяснение (`explanation`) доступно для Edge‑ответа (персонализированный совет после правильного ответа может учитывать эту подсказку).
  - Никаких DDL/изменений схемы; только UPDATE существующих записей `lessons`.
