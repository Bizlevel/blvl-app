# Этап 30: Правки по UX/UI

### Задача 30.1: Уровень 0 — форма профиля в режиме «просмотр/редактирование»
- Цель: после сохранения профиля («Перейти на Уровень 1») поля остаются заполненными и переходят в read-only. В правом верхнем углу блока появляется серая иконка «Редактировать», по нажатию поля становятся активными.
- Файлы: `lib/screens/level_detail_screen.dart` (+минимальные правки в `CustomTextBox`, если потребуется только проп `readOnly`).
- Что сделать:
  1) Поднять состояние формы в `_LevelDetailScreenState`: контроллеры `profileNameCtrl/profileAboutCtrl/profileGoalCtrl`, `selectedAvatarId`, флаг `isProfileEditing` (по умолчанию `true` до первого сохранения), `profileInitialized`.
  2) При первом получении данных `currentUserProvider` заполнить контроллеры и `selectedAvatarId`, затем `profileInitialized = true`.
  3) Передать контроллеры/`selectedAvatarId`/`isProfileEditing` в `_ProfileFormBlock` через конструктор; внутри блока убрать создание собственных контроллеров.
  4) В UI формы использовать `CustomTextBox(readOnly: !isProfileEditing)` и добавить `IconButton(Icons.edit, color: Colors.grey)` в правом верхнем углу блока. По нажатию переключать `isProfileEditing = true`.
  5) После успешного `AuthService.updateProfile(...)` ставить `isProfileEditing = false` и `_profileSaved = true` (для логики «Завершить уровень»). Значения в полях остаются от контроллеров — повторный заход отображает их сразу.
- Критерии приёмки:
  - После нажатия «Перейти на Уровень 1» при повторном открытии уровня 0 поля предзаполнены из профиля и заблокированы для редактирования.
  - Иконка «Редактировать» присутствует; после нажатия поля становятся активными, повторное сохранение обновляет профиль.
  - Никаких изменений схемы БД; используются существующие `updateProfile` и провайдеры.

### Задача 30.2: Страница «Цель» — read-only после сохранения + иконка «Редактировать»
- Цель: по умолчанию существующая последняя версия цели отображается в режиме просмотра; поля становятся редактируемыми только по нажатию на серую иконку «Редактировать». Автосохранение отключено в режиме просмотра.
- Файлы: `lib/screens/goal_screen.dart`.
- Что сделать:
  1) Добавить флаг `_isEditing`. Инициализация: если версия отсутствует — `_isEditing = true`; если версия существует — `_isEditing = false` (только последняя версия доступна для редактирования).
  2) При переключении версии устанавливать `_isEditing = (выбранная версия == последняя)`.
  3) Во все `CustomTextBox` передать `readOnly: !_isEditing`. Кнопку «Сохранить» блокировать, если `_isEditing == false`.
  4) В заголовке «Кристаллизация цели vX» добавить `IconButton(Icons.edit, color: Colors.grey)`; клик переводит `_isEditing = true` (только для последней версии).
  5) В `_scheduleAutosave()` мгновенно выходить, если `_isEditing == false`.
  6) После успешного `_saveGoal()` — `_isEditing = false`, значения остаются в контроллерах.
- Критерии приёмки:
  - При наличии сохранённой v1 (или выше) форма открывается в read-only, автосохранение не срабатывает; отображается иконка «Редактировать».
  - Нажатие иконки включает редактирование только для последней версии; после «Сохранить» форма снова read-only с актуальными значениями.
  - Поведение версий (создание следующей) не изменено. БД/репозитории остаются прежними (`core_goals`, `GoalsRepository`).

### Задача 30.3: Переименование бота «Алекс» → «Макс» (БД + Edge + клиент)
- Цель: унифицировать имя бота‑трекера везде как «Макс»/`max`.
- Файлы/инструменты: `supabase/functions/leo-chat/index.ts`, `lib/services/leo_service.dart`, `lib/screens/goal_screen.dart`, `lib/screens/leo_chat_screen.dart`, `lib/widgets/floating_chat_bubble.dart`, `lib/screens/leo_dialog_screen.dart`, supabase‑mcp (миграция).
- Что сделать:
  1) БД (через supabase‑mcp `apply_migration`):
     - `UPDATE public.leo_chats SET bot = 'max' WHERE bot = 'alex';`
     - Переопределить CHECK на колонке `leo_chats.bot` → `CHECK (bot in ('leo','max'))`.
  2) Edge Function `leo-chat`: трактовать `bot` как строку `'leo' | 'max'`; временно поддержать входящий `'alex'` как `'max'` для совместимости. Тексты промпта обновить: «Ты — Макс…».
  3) Клиент: заменить все сравнения/передачи `'alex'` → `'max'`; русские подписи «Алекс» → «Макс». В `GoalScreen` для bubble `bot: 'max'`.
- Критерии приёмки:
  - Список чатов фильтруется по `bot='leo'/'max'`, старые записи с `'alex'` видны как `'max'`.
  - Отправка сообщений с `bot='max'` работает; edge‑функция возвращает ответы без регрессий.

### Задача 30.4: Страница «Чат» — выбор бота карточками
- Цель: заменить чипы «Лео/Макс» на две большие кнопки‑карточки по центру экрана.
- Файлы: `lib/screens/leo_chat_screen.dart`, ассеты `assets/images/avatars/avatar_leo.png`, `assets/images/avatars/avatar_max.png` (уже есть).
- Что сделать:
  1) В шапке оставить счётчик сообщений для активного бота, убрать текущий заголовок аватар и имя бота
  2) Вместо `_buildBotSwitcher()` отрисовать две карточки одинакового размера:
     - Лео: аватар, «Лео AI», подпись серым «Твой бизнес‑ментор».
     - Макс: аватар `avatar_max.png`, «Макс AI», подпись серым «Твой помощник в достижении цели».
     - Активную карточку подсвечивать (обводка/фон), по нажатию — переключать `_activeBot` и перезагружать список.
- Критерии приёмки: карточки по центру, корректная подсветка активного, фильтрация чатов работает.

### Задача 30.5: FAB/баббл — «Новый чат с …» + мини‑ава
- Файлы: `lib/screens/leo_chat_screen.dart`, `lib/widgets/floating_chat_bubble.dart`.
- Что сделать:
  1) В тексте заменить «Новый диалог с …»/«Обсудить с …» → «Новый чат с Лео/Максом».
  2) Вставить слева маленький `CircleAvatar` бота (соответствующий аватар).
- Критерии приёмки: корректные подписи и аватары для обоих ботов.

### Задача 30.6: Шапка окна диалога — аватар + имя на кириллице
- Файлы: `lib/screens/leo_dialog_screen.dart`.
- Что сделать: в `AppBar.title` вместо текста «Диалог с …» отрисовать Row: аватар бота + имя «Лео»/«Макс» (кириллица), выровнять по центру, сохранить цветовую схему.
- Критерии приёмки: правильные имена/аватары по типу бота, без переломов макета на мобильном и web.

# Этап 31: Замена тестов на чат

### Задача 31.1: Анализ и подготовка данных квиза
- Цель: убедиться, что текущие данные уроков подходят для «чат‑теста» без миграций схемы.
- Что сделать:
  1) Проверить, что у всех уроков, где есть квиз, в `lessons.quiz_questions[0]` присутствуют поля `question: string`, `options: string[]` и есть соответствующий `correct_answers[0]: int`.
  2) (Опционально) Для каждого такого квиза добавить поле `script` в JSON `quiz_questions[0]` — короткая установка от имени Лео (если поле отсутствует, клиент покажет дефолтное приветствие).
- База данных: миграции не требуются; работаем с существующей структурой `lessons`.

### Задача 31.2: Клиент — новый виджет `LeoQuizWidget`
- Файлы: `lib/widgets/leo_quiz_widget.dart` (новый), `lib/screens/level_detail_screen.dart` (использование в блоке квиза).
- Что сделать:
  1) Создать виджет `LeoQuizWidget` с пропсами: `questionData`, `onCorrect`, `initiallyPassed`, `userContext`.
  2) UI: первое сообщение ассистента (из `questionData.script` или дефолт), список вариантов ответа кнопками под зоной ввода, компактная лента сообщений (1–2 сообщения), без истории.
  3) Поведение: локально проверять выбор (`selectedIndex == correctIndex`), запрашивать короткий ответ от Лео (успех/подсказка), при верном ответе — дизейблить варианты и вызывать `onCorrect(pageIndex)` для разблокировки «Далее».
  4) Поддержать `initiallyPassed: true` — сразу показывать состояние «пройдено», без возможности повторного ввода.
  5) Обработка ошибок/оффлайн: при недоступности Edge отобразить локальную заготовку ответа; «Далее» разрешать после локальной валидации верного варианта (поведение задать как дефолтное, чтобы не блокировать прогресс оффлайн).

### Задача 31.3: Клиент — сервис `LeoService.sendQuizFeedback`
- Файл: `lib/services/leo_service.dart`.
- Что сделать:
  1) Добавить метод `Future<Map<String, dynamic>> sendQuizFeedback({ required String question, required List<String> options, required int selectedIndex, required int correctIndex, required String userContext, int maxTokens = 180 })`.
  2) Вызов: POST `/leo-chat` с телом `{ mode: 'quiz', isCorrect, quiz: { question, options, selectedIndex, correctIndex }, userContext, maxTokens }`.
  3) В режиме `quiz` не выполнять `decrementMessageCount()` и не вызывать `saveConversation()` — эти сообщения не должны расходовать общий лимит и не должны создавать записи в `leo_chats/leo_messages`.
  4) Таймауты/ретраи — как в существующих методах; маппинг ошибок в `LeoFailure` и отдельное сообщение для оффлайн.
  5) Наблюдаемость: оборачивать ошибки в Sentry (`captureException`) без PII.

### Задача 31.4: Edge Function `leo-chat` — режим `mode='quiz'`
- Файл: `supabase/functions/leo-chat/index.ts`. Инструменты: supabase‑mcp для деплоя.
- Что сделать:
  1) Принимать payload с `mode: 'quiz'`, `isCorrect: boolean`, `quiz: { question, options, selectedIndex, correctIndex }`, `userContext: string`, `maxTokens?: number`.
  2) Для `mode='quiz'` отключить RAG/память/историю и любые записи в БД; ответ строить как одно короткое сообщение ассистента. Уважать `maxTokens` (по умолчанию 160–200), температуру снизить.
  3) Системный промпт на русском: краткий, без «чем ещё помочь». Ветвление по `isCorrect`: 
     - неверно — поддержка и мягкая подсказка, не раскрывая правильный вариант;
     - верно — короткое поздравление и 2–3 строки персональной применимости на основе `userContext` (`users.name/goal/about`).
  4) Логирование: структурированное, без PII.
  5) Совместимость: текущие ветки Лео/Макс без изменений; `mode='quiz'` — отдельная ветка ответа, не влияющая на обычный чат.

### Задача 31.5: Интеграция в маршрут уровня
- Файл: `lib/screens/level_detail_screen.dart`.
- Что сделать:
  1) Внутри `_QuizBlock` заменить `QuizWidget` на `LeoQuizWidget`, сохранив логику `onCorrect(index)` и `initiallyPassed`.
  2) Передавать `userContext`, собранный из `currentUserProvider` (минимум: имя, цель, о себе) в компактной строке.
  3) Никаких изменений в `_isLevelCompleted()` и прогрессе не требуется: `onCorrect(index)` по‑прежнему вызывает `markQuizPassed(index)` и `unlockNext(index)`.

### Задача 31.6: Фича‑флаг и обратная совместимость
- Файлы: `lib/screens/level_detail_screen.dart`, (опц.) `lib/utils/constant.dart`.
- Что сделать:
  1) Ввести флаг `kUseLeoQuiz` (compile‑time или константа), включающий новый виджет `LeoQuizWidget`.
  2) При `kUseLeoQuiz == false` рендерить старый `QuizWidget` — безопасное поэтапное включение.

### Задача 31.7: Тесты
- Файлы: `test/level_detail_screen_test.dart`, `test/services/leo_service_test.dart`, `test/widgets/leo_quiz_widget_test.dart`, `test/web_smoke_test.dart` (добавление сценария).
- Что проверить:
  1) Разблокировка «Далее» после верного ответа в `LeoQuizWidget` и вызова `onCorrect`.
  2) `LeoService.sendQuizFeedback` — корректный payload, заголовки, обработка сетевых ошибок.
  3) Оффлайн‑сценарий: локальное поздравление и возможность продолжить.
  4) Web‑рендер `LeoQuizWidget` с мок‑сервисом — отсутствие ошибок.

### Задача 31.8: Наблюдаемость и безопасность
- Файлы: `lib/services/leo_service.dart`, `supabase/functions/leo-chat/index.ts`.
- Что сделать:
  1) Логировать ошибки в Sentry на клиенте (без PII), в Edge — структурированные логи (без пользовательских данных).
  2) Убедиться, что режим `quiz` не изменяет лимиты сообщений пользователя и не создаёт записи в `leo_chats/leo_messages`.
  
### Задача 31.9: Миграция вопросов/вариантов/комментариев из `docs/archive/Вопросы для тестов.md` в Supabase
- Цель: перенести подготовленные вопросы (уровни 1–10, блоки 1–4) в БД, чтобы «чат‑тест» использовал реальные данные.
- Таблицы/схема: без изменений. Используем существующие поля в `public.lessons`:
  - `quiz_questions jsonb[]` — кладём один объект c ключами: `{ question, options, correct, script?, explanation? }`;
  - `correct_answers int[]` — массив из одного индекса `correct`.
- Маппинг:
  1) Соотнести разделы markdown по заголовкам «Уровень N» с записями `levels.number = N`.
  2) Внутри уровня привязать «Блок 1..4» к `lessons(order = 1..4)` по возрастанию `order`.
  3) Если количество уроков ≠ количеству блоков:
     - уроков больше — заполняем первые K блоков, остальные квизы оставляем пустыми;
     - уроков меньше — используем первые K блоков из markdown, остальные пропускаем (внести в TODO на дополнение уроков/контента).
  4) `options` — список вариантов (A..D) в порядке; `correct` — индекс правильного варианта (0..3) по букве; `explanation` — абзац после «Правильный ответ»; `script` — короткое вступление Лео (если нет в md — сгенерировать дефолт «Давай проверим понимание…»).
- Реализация:
  1) Написать одноразовый конвертер `scripts/quiz_md_to_json.py` (или `.dart`): парсинг md → JSON‑карта `{ level, block, question, options[], correctLetter, explanation }`.
  2) Генерировать SQL‑файл с `UPDATE public.lessons SET quiz_questions = '[{...}]'::jsonb[], correct_answers = ARRAY[<idx>] WHERE level_id = <id> AND "order" = <block>;` для каждого урока.
  3) Запустить SQL через supabase‑mcp (`execute_sql`) батчами по уровню.
- Проверка/валидация:
  1) Выборки: `select level_id, "order", quiz_questions, correct_answers from public.lessons where level_id in (select id from levels where number between 1 and 10) order by level_id, "order";`
  2) Ручной просмотр 2–3 уровней в клиенте: отображается вступительное сообщение, варианты присутствуют, верный индекс работает.
  3) Локальный тест «прогресс» — `onCorrect` срабатывает, «Далее» активна.
- Критерии приёмки:
  - Во всех уровнях 1–10 у соответствующих уроков заполнены `quiz_questions[0]` и `correct_answers[0]`.
  - Объяснение (`explanation`) доступно для Edge‑ответа (персонализированный совет после правильного ответа может учитывать эту подсказку).
  - Никаких DDL/изменений схемы; только UPDATE существующих записей `lessons`.


### Задача 31.10: Критерии приёмки
- После просмотра видео появляется блок «чат‑тест» вместо старого квиза.
- Неверный ответ — поддержка и предложение попробовать ещё раз; «Далее» неактивна.
- Верный ответ — короткое поздравление + персональная применимость; блок фиксируется как пройденный, «Далее» активна.
- Прогресс уровня и завершение работают без изменений; БД‑миграции не нужны.
- Режим `quiz` не создаёт чатов и не тратит лимит сообщений.
- Оффлайн или сбой Edge — показать локальный ответ и разрешить «Далее» после верной локальной проверки.
- Перерасход токенов — жёсткий `maxTokens` и лаконичный системный промпт.
- Регрессии UI — фича‑флаг и поэтапное включение; fallback на `QuizWidget`.

### Задача 31.11: LeoQuizWidget — чат‑оформление (хедер и лента сообщений)
- Цель: визуально сделать блок квиза как открытый чат с Лео — сверху аватар и имя «Лео», справа бейдж «Вопрос X.Y», ниже лента сообщений (сообщения Лео).
- Файлы: `lib/widgets/leo_quiz_widget.dart`, `lib/screens/level_detail_screen.dart`, ассеты `assets/images/avatars/avatar_leo.png` (уже есть).
- Что сделать:
  1) В `LeoQuizWidget` добавить параметры `levelNumber` и `questionIndex`.
  2) В `_QuizBlock` пробросить `levelNumber: widget.levelNumber ?? widget.levelId`, `questionIndex: lesson.order`.
  3) Сверху отрисовать хедер: `CircleAvatar(avatar_leo.png)` + текст «Лео»; справа — `Chip` «Вопрос {levelNumber}.{questionIndex}» с фоном `AppColor.primary.withOpacity(0.1)` и текстом `AppColor.primary`.
  4) В зоне контента заменить статические контейнеры на ленту сообщений с использованием `LeoMessageBubble`:
     - первое сообщение Лео — `script` (если отсутствует — дефолтная фраза);
     - второе сообщение Лео — сам текст вопроса.
  5) Поддержать `initiallyPassed`: карточки выбора отключены, под вопросом короткое сообщение Лео «Тест уже пройден ✅» (или `explanation`, если есть).
- Критерии приёмки:
  - Хедер и лента выглядят как в реальном диалоге; шрифты/отступы согласованы с существующим экраном чата.
  - Логика прогресса, сетевые вызовы и фича‑флаг не меняются.

### Задача 31.12: Выбор ответов карточками + отличающийся цвет (без путающих «кнопок»)
- Цель: варианты ответа показывать как кликабельные карточки (не Radio/кнопки) с нейтральной подсветкой, чтобы визуально отличались от навигационных кнопок «Назад/Обсудить/Далее» и при этом сохраняли логику переписки.
- Файлы: `lib/widgets/leo_quiz_widget.dart`.
- Что сделать:
  1) Заменить `RadioListTile` на список карточек‑вариантов:
     - базовый стиль: `Container` с закруглением 12, тонкая рамка `Colors.grey.shade300`, фон `Colors.white`;
     - при выборе: фон `Colors.blue.shade50`, рамка `AppColor.primary`, иконка галочки справа.
  2) При тапе по карточке:
     - мгновенно добавить в ленту пользовательский бабл (`LeoMessageBubble(isUser: true)`) с текстом выбранного варианта;
     - запустить существующую проверку (`_sendAssistantReply`); на время ответа заблокировать выбор других вариантов;
     - кнопку «Проверить» скрыть (не используется).
  3) По завершении проверки добавить бабл Лео с результатом (`_assistantMessage`); при верном ответе вызывать `onCorrect()` (как сейчас).
  4) Цветовое различие: карточки вариантов используют нейтральную палитру (белый фон + серая рамка, активное состояние — светло‑голубой фон), чтобы не конфликтовать визуально с основными кнопками экрана. Пользовательский бабл остаётся фирменного цвета `AppColor.primary`.
- Критерии приёмки:
  - Варианты визуально отличаются от навигационных кнопок; UX однозначно воспринимается как «диалог + варианты».
  - Выбор запускает проверку без дополнительной кнопки; оффлайн‑фолбэк работает как прежде.

# Этап 32: Дизайн и UX
 
### Задача 32.1: Глобальная компоновка страницы «Цель» (каркас и ритм)
- Цель: сделать страницу легче для сканирования на web/mobile за счёт ограничителя ширины, единого каркасного стиля карточек и ровного вертикального ритма. Логику и провайдеры не менять.
- Файлы: `lib/screens/goal_screen.dart` (основной), (опц.) `lib/theme/color.dart` (добавить мягкие нейтрали/градиент при необходимости, без BC‑лома).
- Что сделать:
  1) Обернуть контент `GoalScreen` в `Center` + `ConstrainedBox(maxWidth: 840)` для web/desktop; на мобильном поведение без изменений.
  2) Привести секции к единому каркасу (существующий контейнер с белым фоном/тенью): мотивация, версии, форма версии, «Путь к цели» — одинаковые отступы 16–24 px.
  3) В верхнем заголовке: «Цель» + серый подзаголовок «Сформулируйте цель и пройдите 4 версии». Справа небольшой статус‑чип «Версия X из 4» и «Доступно до vY» (на основе текущего уровня).
  4) Заменить подпись «Автосохранение каждые 200 мс» на чип режима: «Режим: Просмотр/Редактирование» (цвет нейтральный/первичный). Автосохранение не включать.
- Критерии приёмки:
  - На экранах ≥1024 px ширина контента визуально ограничена (≤ 840 px), без горизонтальных переполнений.
  - Все секции выглядят консистентно: одинаковая тень, скругление, внутренние отступы; вертикальные интервалы ровные.
  - Текст про автосохранение исчез, отображается чип режима.

### Задача 32.2: Навигация версий (v1–v4) со статусами
- Цель: повысить понятность и мотивацию при переключении версий, сохранив текущую логику гейтинга.
- Файлы: `lib/screens/goal_screen.dart`.
- Что сделать:
  1) Обновить лейблы: `v1 Семя`, `v2 Метрики`, `v3 SMART`, `v4 Финал` (русские подписи).
  2) Показать статусы: текущая — подсветка; завершённые — чек ✓; недоступные — иконка замка и `tooltip` «Откроется после Уровня N».
  3) Не менять условия доступности/создания следующей версии — только визуальная индикация.
- Критерии приёмки:
  - Пользователь видит понятные подписи и статусы версий; при ховере/табе на заблокированную показывает подсказку.
  - Переключение и гейтинг работают как прежде; сохранение форм не изменилось.

### Задача 32.3: Формы v1–v4 — читаемость и дружелюбные подсказки
- Цель: улучшить сканируемость и снизить когнитивную нагрузку в формах версий без изменения полей/валидаций.
- Файлы: `lib/screens/goal_screen.dart` (только вёрстка и тексты).
- Что сделать:
  1) Сгруппировать поля по смыслу под мини‑подзаголовками («Почему сейчас», «Препятствие», «Метрика»). Реализовать разметкой внутри файла, без выноса новых публичных виджетов.
  2) Уточнить `hint`‑тексты (1 строка, тёплый тон, пример). Поля чисел (v2) по возможности настроить на числовую клавиатуру (если `CustomTextBox` поддерживает `keyboardType`).
  3) В v4 переключатель «Готов к реализации» оформить как `Switch` с подписью справа; поведение `_commitment` оставить прежним.
  4) Кнопки: primary «Сохранить», справа чип «Просмотр/Редактирование»; иконка «Редактировать» остаётся в заголовке блока.
- Критерии приёмки:
  - Поля логически сгруппированы; подсказки понятные, без длинных текстов.
  - На мобильном числовые поля открывают цифровую клавиатуру (где поддерживается компонентом).
  - После «Сохранить» режим возвращается в «Просмотр» (как сейчас); логика валидаций/запросов не менялась.

### Задача 32.4: «Путь к цели» — визуальный прогресс спринта
- Цель: сделать блок спринтов наглядным (7 дней, текущий спринт), не меняя текущих данных и API.
- Файлы: `lib/screens/goal_screen.dart`.
- Что сделать:
  1) Заголовок: «Путь к цели • Спринт S» + лёгкая плашка «7 дней».
  2) Мини‑timeline из 7 точек (вертикально/горизонтально в зависимости от ширины) с подписями «День n»; текущий день можно отображать нейтрально (без вычислений по дате, чтобы не трогать логику).
  3) Форму чек‑ина визуально облегчить: на desktop — две колонки, на mobile — одна; «Проверки недели» (чипы) сгруппировать в отдельный подпункт.
  4) После сохранения чек‑ина показать вторичную кнопку‑CTA «Обсудить с Максом» (выполняет то же действие, что нажатие плавающего баббла).
- Критерии приёмки:
  - Есть 7‑точечная шкала дней спринта; верстка не ломается на web/mobile.
  - При сохранении чек‑ина отображается CTA к чату; существующая логика сохранения не меняется.

### Задача 32.5: Блок «Мотивация» — аватар Макса, градиент, скелетон
- Цель: сделать мотивационный блок вдохновляющим и компактным, с аккуратной загрузкой/ошибками.
- Файлы: `lib/screens/goal_screen.dart` (вёрстка), ассеты уже есть (`assets/images/avatars/avatar_*.png`).
- Что сделать:
  1) Левая колонка: `CircleAvatar(Max)`; правая — цитата (2–3 строки) + автор; фон — мягкий градиент/подсветка из темы.
  2) В состоянии загрузки — скелетон (серые плашки); при ошибке — дружелюбный текст «Сегодня работаем по плану — без цитаты».
- Критерии приёмки:
  - Визуально блок с аватаром и аккуратным фоном; загрузка и ошибка выглядят ненавязчиво.
  - Длина цитаты не приводит к переполнению/обрезке на мобильном.

### Задача 32.6: Доступность, состояния и типографика
- Цель: унифицировать доступность (минимальные размеры интерактивов), пустые/ошибочные состояния и типографику desktop.
- Файлы: `lib/screens/goal_screen.dart`, (опц.) `lib/theme/color.dart`.
- Что сделать:
  1) Минимальная высота кликабельных элементов ≥ 44 px; увеличить `title` на desktop на +1 pt.
  2) Пустые состояния: «Путь к цели доступен после v4», «Цитата недоступна» — с иконкой и коротким дружелюбным текстом.
  3) Локализация/копирайтинг: выровнять терминологию («цель», «спринт», «версия») и тон сообщений.
- Критерии приёмки:
  - Интерактивы соответствуют минимальным размерам; тексты унифицированы, переполнений нет.
  - Нет новых предупреждений анализатора/линутера, существующие тесты не ломаются.

### Задача 32.7: Наблюдаемость и регресс‑чек
- Цель: убедиться, что визуальные правки не вносят регрессии и не создают UI‑исключений.
- Файлы/инструменты: `lib/screens/goal_screen.dart`; sentry‑mcp (чтение логов за последние 24 ч), локальные тесты.
- Что сделать:
  1) Прогнать `flutter analyze` и существующие тесты (`flutter test`).
  2) Через sentry‑mcp убедиться в отсутствии свежих RenderFlex overflow/Layout ошибок, связанных с `GoalScreen`.
  3) На web проверить ширину контейнера и отсутствие горизонтального скролла.
- Критерии приёмки:
  - Sentry не показывает новые критические UI‑ошибки, тесты и анализ проходят.
  - Визуальные изменения соответствуют макету из задач 32.1–32.6, логика данных/запросов неизменна.

### Задача 32.8: Плавающий баббл «Новый чат с Максом» — смещение вниз
- Цель: баббл не должен перекрывать контент и находиться в правом нижнем углу.
- Файлы: `lib/screens/goal_screen.dart`.
- Что сделать:
  1) В `Positioned` для `FloatingChatBubble` установить `right: 16`, `bottom: 16` (без `+ kBottomNavigationBarHeight`).
  2) Проверить на iOS/Android/Web — баббл не перекрывает кнопки сохранения и поля.
- Критерии приёмки:
  - Баббл всегда виден и не перекрывает основной контент на мобильном и web.

### Задача 32.9: Заголовок экрана «Цель» — только центровка, без подзаголовков
- Цель: упростить шапку согласно макету.
- Файлы: `lib/screens/goal_screen.dart`.
- Что сделать:
  1) В `AppBar` оставить только заголовок «Цель», выровнять по центру (`centerTitle: true`).
  2) Удалить подзаголовок «Сформулируйте цель и пройдите 4 версии» и правый чип «Версия X из 4»/индикатор доступности.
- Критерии приёмки:
  - В шапке отображается только слово «Цель» по центру.

### Задача 32.10: Блок «Кристаллизация цели» — заголовок и версия‑чипы
- Цель: убрать «vN» из лейблов версий и устранить overflow на мобильном.
- Файлы: `lib/screens/goal_screen.dart`.
- Что сделать:
  1) Заголовок блока: «Кристаллизация цели» (без «vN»).
  2) Перечень версий отрисовывать под заголовком с лейблами: «1. Семя», «2. Метрики», «3. SMART», «4. Финал».
  3) Заменить `Row` на `Wrap` (`alignment: WrapAlignment.center`, `spacing: 8`, `runSpacing: 8`) для предотвращения «right overflow» на мобильном.
- Критерии приёмки:
  - На узких экранах нет жёлто‑чёрной полосы overflow; лейблы версий читаемы и центрированы.

### Задача 32.11: Блок "Кристаллизация цели" - Поля — placeholder вместо подписи под заголовком
- Цель: сократить уровень вложенности подписей и привести к единому виду как в «Путь к цели».
- Файлы: `lib/screens/goal_screen.dart`, (опц.) `lib/widgets/custom_textfield.dart`.
- Что сделать:
  1) Для v1 под заголовком группы «Основная цель» сразу показывать `CustomTextBox` с `hint: "Чего хочу достичь за 28 дней"`. Применить этот подход ко всем заполняемым полям в v2–v4.
  2) В этой секции не выводить отдельную подпись `_LabeledField` — только поле с hint (серый текст исчезает при фокусе по умолчанию). Применить этот подход ко всем заполняемым полям в v2–v4.
- Критерии приёмки:
  - В v1–v4 под Заголовком заполняемого поля виден только инпут с серым hint.

### Задача 32.12: Режим просмотра/редактирования — без чипа, визуальная индикация
- Цель: убрать чип «Режим: …» и сделать лёгкую серую подложку у readOnly‑полей.
- Файлы: `lib/screens/goal_screen.dart`, `lib/widgets/custom_textfield.dart`.
- Что сделать:
  1) Удалить Chip «Режим: Просмотр/Редактирование» внизу формы.
  2) В `CustomTextBox` добавить условный фон: если `readOnly == true` — `Colors.grey.shade100`, иначе белый. Изменение сделать параметризуемым, чтобы не ломать другие экраны.
  3) Триггер перевода в редактирование остаётся на иконке «карандаш».
- Критерии приёмки:
  - В режиме просмотра поля заметно (но не навязчиво) серые; при редактировании — белые. Чип режима отсутствует.

### Задача 32.13: «Путь к цели» — заголовок и порядок элементов
- Цель: соответствовать макету и улучшить читаемость.
- Файлы: `lib/screens/goal_screen.dart`.
- Что сделать:
  1) Заголовок упростить до «Путь к цели» (убрать «• Спринт X» и чип «7 дней»).
  2) Переставить элементы: сначала центрированные чипы «Спринт 1..4», ниже — мини‑таймлайн 7 дней, тоже по центру.
- Критерии приёмки:
  - Заголовок без дополнительных пометок; дни расположены под переключателями спринтов и центрированы.

### Задача 32.14: «Проверки недели» — вместо чекбоксов текстовые поля
- Цель: собирать осмысленные заметки и хранить их в БД.
- Файлы: `lib/screens/goal_screen.dart`, `lib/repositories/goals_repository.dart`, `lib/models/weekly_progress_model.dart`, миграция `supabase/migrations/20250814_28x_weekly_progress_details.sql`.
- Миграция (через supabase‑mcp):
  - `alter table public.weekly_progress add column if not exists artifacts_details text;`
  - `alter table public.weekly_progress add column if not exists consulted_benefit text;`
  - `alter table public.weekly_progress add column if not exists techniques_details text;`
- Что сделать (клиент):
  1) Заменить три `FilterChip` на три `CustomTextBox` с подписями и серыми подсказками:
     - «Использовал артефакты» → hint «Какие именно».
     - «Консультировался с тренерами» → hint «Какую пользу извлекли».
     - «Применял техники из уроков» → hint «Какие техники были полезными».
  2) Добавить контроллеры, загрузку из БД в `_loadSprintIfAny()` и передачу значений в `GoalsRepository.upsertSprint(...)`.
  3) В `GoalsRepository.fetchSprint()` включить новые колонки в `select`, а в `upsertSprint()` — добавить опц‑параметры `artifactsDetails`, `consultedBenefit`, `techniquesDetails` и отправлять их в payload (булевы флаги можно оставить как есть или проставлять `true`, если текст не пуст).
  4) Обновить `WeeklyProgressModel` (+ `freezed/g.dart`) с 3 новыми опциональными полями.
- Критерии приёмки:
  - Значения сохраняются в `weekly_progress.*_details`, загружаются при повторном открытии и корректно отображаются.

### Задача 32.15: Проверки, тесты и наблюдаемость
- Цель: убедиться в отсутствии регрессий.
- Что сделать:
  1) `flutter analyze` — без новых warning’ов уровня warning/error.
  2) `flutter test` — проходят существующие; при необходимости обновить моки репозитория для новых полей.
  3) Через sentry‑mcp проверить отсутствие новых RenderFlex/overflow ошибок после открытия/скролла экрана «Цель» и сохранения чек‑ина.
- Критерии приёмки:
  - Анализ и тесты зелёные, в Sentry нет свежих критических UI‑ошибок, связанных с `GoalScreen`.

  ### Задача 32.16: Профиль — счётчик артефактов, модалка и скрытие секции
- Цель: исправить склонение «артефакт(а/ов)», заменить иконку на «сундук», сделать счётчик кликабельным (стрелка в правом верхнем углу) и по нажатию открывать модальный список доступных артефактов; скрыть дублирующую секцию «Артефакты» под «Шкалой навыков».
- Файлы: `lib/screens/profile_screen.dart` (только), переиспользуем `levelsRepositoryProvider` для подписывания URL. `lib/widgets/stat_card.dart` и `lib/widgets/artifact_card.dart` не изменяются.
- Что сделать:
  1) Склонение: добавить приватную функцию `_pluralizeArtifacts(int n)` в `_BodyState` и заменить строку в `_buildRecord()` на: `${count} ${_pluralizeArtifacts(count)}`. Правила: 1 — «Артефакт», 2–4 — «Артефакта», 5–20 — «Артефактов», учитывать исключения 11–14 и циклы по последней цифре.
  2) Иконка: заменить `Icons.shield_outlined` на «сундук» — `Icons.inventory_2_outlined` (Material). Цвет и размеры как у соседних карточек.
  3) Кликабельность и индикатор: обернуть третий `StatCard` (артефакты) в `InkWell`/`GestureDetector`; визуально добавить стрелку `Icons.expand_more` в правый верхний угол карточки через `Stack` на месте использования, чтобы подсказать интерактивность.
  4) Модалка: по нажатию открывать `showModalBottomSheet(isScrollControlled: true)` с `DraggableScrollableSheet` и списком доступных артефактов. Элемент списка: компактный `ListTile` (иконка загрузки/мини‑картинка, заголовок, описание, кнопка «скачать»). Для относительных путей подписывать через `ref.read(levelsRepositoryProvider).getArtifactSignedUrl(path)`, затем открывать через `url_launcher`. Пустое состояние: «У вас пока нет артефактов».
  5) Ошибки/оффлайн: показывать `SnackBar` с понятными сообщениями («Нет соединения с интернетом», «Не удалось открыть файл»); неожиданные исключения отправлять в Sentry (`captureException`).
  6) Скрыть нижнюю секцию: удалить/закомментировать вызов `_buildArtifactsSection()` под «Шкалой навыков», чтобы исключить дублирование. При необходимости оставить секцию только на desktop в будущем (не в рамках задачи).
- Критерии приёмки:
  - Счётчик отображает корректное склонение (например: 1 Артефакт, 2 Артефакта, 5 Артефактов, 11 Артефактов, 21 Артефакт).
  - Иконка заменена на сундук; в правом верхнем углу карточки видно стрелку, карточка нажимается.
  - По нажатию открывается модалка со списком доступных артефактов; относительные пути корректно подписываются и открываются; при пустом списке — дружелюбное сообщение.
  - Секция «Артефакты» под «Шкалой навыков» больше не отображается.
  - `flutter analyze` без новых ошибок/варнингов уровня warning/error; существующие тесты не ломаются.
- Тесты:
  - Юнит‑тест функции склонения (наборы: 0–25, 101–114) на корректные формы.
  - (Опционально) widget‑тест: при `artifactsCount > 0` нажатие на карточку открывает модалку.
- Бэкенд/миграции: не требуются; используем существующий `levelsRepositoryProvider.getArt∆ifactSignedUrl`.

# Этап 33: Main Street и «Этажи» (Level)

Цель этапа: заменить текущую «Карту уровней» на концепт «Main Street → Level (этаж) → Tower», сохранив существующие данные и логику. База данных Supabase не меняется (MVP); отображаемый код уровня вычисляется на клиенте как FNN: `floorId*100 + levelNumber` (например, 101 = этаж 1, уровень 1). На главном экране используем названия зданий: слева — «Библиотека» и «Фуд‑индустрия», центр — «БизЛевел», справа — «Коворкинг (стартапы/IT/AI)» и «Маркетплейс».

### Задача 33.1: Роутинг и каркас экранов
- Файлы: `lib/routing/app_router.dart`, `lib/app_shell.dart` (если требуется подпись таба)
- Что сделать:
  1) На маршруте `/home` рендерить новый экран `MainStreetScreen` (вместо текущего списка уровней).
  2) Добавить маршруты: `/floor/1` (экран этажа 1 — адаптация текущего экрана уровней), `/tower` (обзор этажей — MVP).
  3) Переименовать таб «Карта уровней» в «Главная»/`Main Street` (подпись, логика табов без изменений).
- Критерии приёмки: приложение открывается на `MainStreetScreen`; переходы `Main Street → /level/1 → /tower` работают, back‑навигация штатная.

### Задача 33.2: Провайдер «Куда продолжить» и формат кода уровня
- Файлы: `lib/providers/levels_provider.dart` (селектор), `lib/utils/formatters.dart` (опц.)
- Что сделать:
  1) Создать `nextLevelToContinueProvider` (селектор над `levelsProvider` и профилем): учитывает `users.current_level`, `isCompleted`, `isPremium` и активную подписку; возвращает `{ levelId, levelNumber, floorId = 1, requiresPremium: bool }`.
  2) Утилита `formatLevelCode(int floorId, int levelNumber) => floorId*100 + levelNumber` (как строка). Для уровня 0 показывать «Ресепшн».
- Критерии приёмки: кнопка на главной показывает «Продолжить: Уровень 10X/101…»; если `requiresPremium==true` и подписки нет — готовит переход на `/premium`, иначе — к нужному `LevelDetailScreen`.

### Задача 33.3: Экран `MainStreetScreen` (Главная улица)
- Файлы: `lib/screens/main_street_screen.dart`, `assets/images/Bizlevel-map-buildings.png` (при необходимости PNG улицы), reuse `UserInfoBar`.
- Что сделать:
  1) Шапка — `UserInfoBar` (аватар, имя, текущий уровень/прогресс).
  2) Центральная иллюстрация «улицы»: подписи зданий — «Библиотека», «Фуд‑индустрия», «БизЛевел», «Коворкинг», «Маркетплейс».
  3) Нижняя кнопка `ElevatedButton`: «Продолжить: Уровень NNN» (данные из `nextLevelToContinueProvider`) → если `requiresPremium` и нет активной подписки — `context.go('/premium')`, иначе `context.go('/levels/<levelId>')`.
  4) Тапы по боковым зданиям — SnackBar «Скоро». Тап по «БизЛевел» ведёт на `/floor/1` или `/tower` (если этаж 1 завершён).
  5) Ошибки (offline/прочее) — дружелюбные SnackBar + `Sentry.captureException`.
- Критерии приёмки: стабильный рендер на Web/iOS/Android; корректная навигация, отсутствие overflow.

### Задача 33.4: Экран этажа `LevelFloorScreen` (адаптация текущего списка уровней)
- Файлы: переиспользовать `lib/screens/levels_map_screen.dart` (минимальный рефактор/переименование), `lib/widgets/level_card.dart`.
- Что сделать:
  1) Заголовок: «Level 1» (Этаж 1), подзаголовок «База предпринимательства» (константа на MVP).
  2) Кнопка назад «< Main Street».
  3) В `LevelCard` добавить проп `compact`: в свернутом виде карточка показывает код `101/102…` + статус (✓/★/🔒); текущий уровень — «раскрытый» вид (как сейчас).
  4) MVP‑вариант допускает оставление текущей сетки; горизонтальную линию/лист внедрим вторым шагом.
- Критерии приёмки: коды уровней отображаются как `101..110`, клики открывают `LevelDetailScreen`, регрессий нет.

### Задача 33.5: Экран «Башня БизЛевел» (обзор этажей)
- Файлы: `lib/screens/biz_tower_screen.dart`.
- Что сделать:
  1) Вертикальный список: Этаж 0 — «Ресепшн» ✓/→, Этаж 1 — «База» →, этажи 2–4 — 🔒/«Скоро».
  2) Прогресс «N/11 уровней» — на основе `levelsProvider`.
  3) Навигация: этаж 1 → `/floor/1`; остальные — SnackBar «Скоро».
- Критерии приёмки: экран открывается со «Главной», переход на этаж 1 работает.

### Задача 33.6: Нейминг и тексты
- Файлы: строки экранов/виджетов (l10n при наличии).
- Что сделать:
  1) Использовать обозначения: `Main Street`, `Level`, коды `101…110`, «БизЛевел», «Библиотека», «Фуд‑индустрия», «Коворкинг», «Маркетплейс».
  2) Не менять модели/таблицы Supabase; это только тексты. Навигационные события помечать bread‑crumbs в Sentry.
- Критерии приёмки: единообразные подписи, без конфликтов с существующими сущностями.

### Задача 33.7: Интеграция с данными Supabase (без миграций)
- Что сделать:
  1) Ничего не менять в схеме. Расчёт кода FNN — на клиенте (`floorId=1` для уровней 1–10; «Ресепшн» — уровень 0).
  2) При необходимости расширить `levelsProvider` вычисляемыми полями `displayCode`/`isCurrent` (не меняя SQL).
- Критерии приёмки: API‑контракты неизменны; тесты репозиториев зелёные.

### Задача 33.8: Тесты
- Файлы: `test/screens/street_screen_test.dart`, `test/screens/level_floor_screen_test.dart`.
- Что сделать:
  1) «Main Street»: наличие кнопки «Продолжить: Уровень NNN», корректный переход в уровень.
  2) «Этаж»: отображение кодов `101..110`, выделение текущего, переход в `LevelDetailScreen`.
- Критерии приёмки: тесты проходят локально и в CI.

### Задача 33.9: Наблюдаемость и устойчивость
- Что сделать:
  1) Навигацию и загрузки провайдеров — в try/catch с `Sentry.captureException`.
  2) Проверить Web: без overflow/горскролла; брейкпоинты `ResponsiveWrapper` соблюдаются.
- Критерии приёмки: в Sentry нет новых критических UI‑ошибок после навигации Main Street/Level/Tower.

### Задача 33.10: (Опционально, после MVP) Подготовка многоэтажности в БД
- Через supabase‑mcp подготовить черновик миграции (без применения):
  - `floors(id, title, sort_order)`; `levels.floor_id` (DEFAULT 1), индексы и RLS.
  - Просмотр прогресса по этажам через view/materialized view.
- Применять после стабилизации и согласования монетизации этажей.


### Задача 33.12: Визуальная шлифовка Main Street / Башни и эталон «этажа» (исправление недочётов)

- Цель: устранить наложение зданий и упростить масштабирование на главной; закрепить этажи «Башни» у нижней кромки экрана и сделать кнопки этажей кликабельными целиком; довести «этаж 1» (лента уровней 101–110) до вида, соответствующего концепции `@bizlevel-map-concept.md`.
- Связанные файлы/компоненты:
  - `lib/screens/main_street_screen.dart`: приватные виджеты `_StreetScene`, `_BuildingBox`, `_Label` — переработка позиционирования и очертаний зданий, линия «земли».
  - `lib/screens/biz_tower_screen.dart`: каркас башни (вертикальные «стены», «этажи»/кнопки, горизонтальные разделители, привязка к низу экрана).
  - `lib/screens/levels_map_screen.dart` (режим `floorMode=true`): центрированная горизонтальная лента уровней, «пол/потолок», актуальный уровень «раскрыт», аватар и имя под ним, корректные отступы.
  - `lib/widgets/level_card.dart`: компактный режим и размеры бэйджа, внешняя серая рамка (не растягивается до «пола»).
  - `lib/theme/color.dart`: оттенки бренда для обводок/земли/стен.
  - `lib/routing/app_router.dart`: маршруты `/home`, `/floor/1`, `/tower`, `/levels/:id` (поведение без изменений, но используется навигация из новых кликабельных областей).
  - Провайдеры: `levels_provider.dart` (используем `displayCode`/`isCurrent`), `auth_provider.dart` (аватар/имя пользователя для подписи под текущим уровнем).
- Что сделать:
  1) Главная (Main Street)
     - Переход на равномерную сетку позиционирования зданий: 16‑колоночная виртуальная сетка (u = width/16). Для каждого здания задать абсолютные «левая граница/ширина/высота» как доли от u и высоты, исключив отрицательные перекрытия Z‑порядка.
     - Добавить жирную линию земли (цвет бренда) и выровнять НИЗ всех зданий по этой линии. Удалить взаимное «налезание» — здания стоят на одинаковой «земле» и имеют равные горизонтальные интервалы между центрами.
     - Сложные очертания зданий: заменить простой прямоугольник на форму из 2–3 слоёв (корпус + тень + ряд «окон»). Реализовать через `_BuildingBox` (Stack + окна‑ячейки) либо `CustomPainter` без внешних зависимостей. Цвета — из `AppColor`.
     - Точки клика: центральное здание — переход `/floor/1` (или `/tower`, если уровень 10 завершён); боковые — SnackBar «Скоро». Зона клика совпадает с габаритами здания.
  2) Башня BizLevel (`/tower`)
     - Привязать этажи к нижней кромке экрана: использовать `SliverFillRemaining(hasScrollBody:false)` либо `LayoutBuilder` + `Align(alignment: Alignment.bottomCenter)` для списка этажей; над и под блоком — отступы 16–24 px.
     - Добавить вертикальные «стены» (2 вертикальные линии по краям области этажей) и горизонтальные разделители между этажами (имитируют «перекрытия»).
     - Кнопки этажей — кликабельны целиком (Container/Card обёрнут в `InkWell`). Этаж 1 — переход `/floor/1`; «Ресепшн» — `/levels/0`; остальные — SnackBar «Скоро».
     - Визуал: карточки этажей уже «поуже и пошире» — довести до единой ширины, ограниченной «стенами», с тенью и скруглением 12 px.
  3) Этаж 1 (лента уровней 101–110)
     - Центрировать ленту по вертикали экрана (между «потолком» и «полом»), увеличить отступы до и после ленты. Линии «потолок/пол» сделать заметнее (2–3 px) и не перекрывать подписи/аватар.
     - Карточки: внешняя серая рамка не должна «упираться» в пол; небольшая «воздушная» зона снизу (Padding 12–16). 
     - Текущий уровень — «раскрыт»: шире, видно название уровня; под карточкой — аватар пользователя (из `UserInfoBar`) и имя. При необходимости увеличить нижний отступ ленты, чтобы линии «пола» не перекрывали подпись.
     - Уровень 0 («Ресепшн») не выводится в ленте 101–110, доступен из башни (этаж 0).
- Изучить перед правками (read‑only):
  - `lib/screens/main_street_screen.dart` — текущее позиционирование зданий и зоны клика.
  - `lib/screens/biz_tower_screen.dart` — структура списка этажей, текущие стены/разделители.
  - `lib/screens/levels_map_screen.dart` — ветка `floorMode`, «потолок/пол», лента уровней; где выводится аватар/имя.
  - `lib/widgets/level_card.dart` — компактный/раскрытый режим, размеры рамки.
- Шаги реализации (минимальные правки, без новых зависимостей):
  1) Main Street: закрепить равные интервалы и выровнять по земле; усилить очертания зданий, добавить окна (через существующий `_BuildingBox`).
  2) Tower: заменить `ListView` на каркас со стенами и привязкой к низу (Align + ListView/Column); обернуть всю плитку этажа в `InkWell`.
  3) Floor: увеличить отступы сверху/снизу, поднять «пол» ниже аватара/подписи; скрыть уровень 0 из ленты; для текущей карточки обеспечить видимость названия.
  4) Визуальная калибровка на мобильных/планшетах/desktop — поправить коэффициенты сетки (доли u) под брейкпоинты ResponsiveFramework.
- Критерии приёмки:
  - На главной здания не наслаиваются, стоят на одной «земле», интервалы между ними визуально равны. Очертания зданий многослойные (корпус/тень/окна).
  - В Башне «Ресепшн» находится у «земли», этажи идут снизу вверх; вся карточка этажа кликабельна и ведёт на нужный маршрут.
  - На этаже 1 лента ровно по центру экрана, «пол/потолок» не перекрывают подпись/аватар, карточки не «упираются» в пол. Уровень 0 отсутствует в ленте.
  - Нет горизонтального/вертикального overflow на Web/iOS/Android. 
- Тесты/проверки:
  - Widget‑тест Main Street: проверка непересечения зон зданий (по ключам/разметке), клики по центральному/боковым.
  - Widget‑тест Tower: клик по «Этаж 1» ведёт на `/floor/1`, по «Ресепшн» — `/levels/0`, остальные — «Скоро».
  - Widget‑тест Floor: лента центрируется (наличие равных отступов сверху/снизу ± допуск), текущая карточка показывает название; уровень 0 не присутствует.
  - `flutter analyze` — без новых warning/error; Sentry — без свежих RenderFlex/overflow после навигации на все 3 экрана.
- Риски/заметки:
  - Точная подгонка коэффициентов сетки под разные брейкпоинты потребует визуального просмотра в симуляторах; закладываем 1–2 итерации подстройки.
  - Стили/цвета — использовать из `AppColor`, не вводить новые жёсткие hex‑значения.

### Задача 33.13: Main Street / Башня / Этаж — визуальные улучшения (по гайду bizlevel-ui-improvements.md)

- Цель: привести «Улицу», «Башню» и «Этаж 1» к минималистичному контурному стилю с лучшей иерархией и читаемостью на мобильных, без изменения текущей бизнес‑логики и провайдеров.
- Файлы: `lib/screens/main_street_screen.dart`, `lib/screens/biz_tower_screen.dart`, `lib/screens/levels_map_screen.dart`, `lib/widgets/level_card.dart`, (опц.) `lib/theme/color.dart`.
- Что сделать (по блокам):
  1) Улица (Main Street)
     - Увеличить центральную башню на 25–30% относительно текущих зданий (визуальная доминанта).
     - Для боковых зданий (пока «Скоро») задать полупрозрачность `opacity: 0.4`.
     - Добавить лёгкую тень под зданиями (elevation: 1, размытие ~2 px) без влияния на хит‑области.
     - Центр/Башня: добавить минималистичные окна (линии/точки) и выровнять интервалы.
     - Цвет «земли» заменить на `AppColor.dividerColor` (#E2E8F0).
     - Под башней показать компактный индикатор прогресса этажа: «Этаж 1 • X/10», где X — число завершённых уровней из `levelsProvider` (без дополнительных запросов).
     - Кнопка «Открыть Башню» не используется — вход по тапу на башню; сохранить лёгкую подсветку башни (мягкая подложка).
  2) Башня BizLevel
     - Карточки этажей сделать приподнятыми (`elevation: 2`, белая карточка, radius 12).
     - Слева крупная нумерация этажа (fontSize≈28), справа — название.
     - Для доступных этажей отобразить прогресс‑бар под заголовком (фактический — для этажа 1 по завершённым уровням из `levelsProvider`; для остальных — заглушка 0%).
     - Состояния: ✓ завершён (зелёная иконка/акцент), → текущий (синяя рамка 2 px), 🔒 заблокирован (серая карточка `opacity: 0.6`).
  3) Этаж 1 (горизонтальная лента уровней)
     - Уменьшить высоту карточек на ~40%, чтобы помещалось 4-5 на экран (мобильный).
     - В компактных карточках вместо обложек акцентировать код уровня `[101..110]` и название; время и кол‑во уроков вторым рядом «8 минут • 4 урока» (если данные доступны).
     - Добавить горизонтальную «линию‑путь» между карточками; текущая карточка — синий контур.
     - Предпросмотр следующей карточки: видимость ~20% по краям скролла.
     - Индикатор прогресса внизу ленты: 10 точек с заполнением по `isCompleted`.
- Приёмочные критерии:
  - На мобильных (≤380 px) нет наложений, тап‑зоны ≥ 48×48, текст не обрезается; на web/desktop сохранена центровка и отсутствие горизонтального скролла вне ленты.
  - Башня открывается по тапу на центральное здание; визуальные состояния карточек соответствуют прогрессу.
  - На «Этаже 1» видно 4-5 карточки без переполнения; отображается путь и индикаторы.
- Тесты:
  - Обновить/добавить widget‑тесты: 
    - Main Street: наличие индикатора «Этаж 1 • X/10», отсутствие кнопки «Открыть Башню», клик по башне ведёт на `/tower` или `/floor/1`.
    - Башня: проверка состояний карточек (✓/→/🔒) и прогресс‑бара.
    - Этаж: уменьшенная высота карточек, 10 индикаторов прогресса, путь между карточками.
- Замечания/риски:
  - Визуальные коэффициенты для брейкпоинтов могут потребовать 1–2 итерации подстройки; не менять API/модели.
  - Прогресс‑бар этажей кроме 1‑го можно оставить заглушкой до появления данных; контракт UI не меняется.

### Задача 33.14: Main Street — переход на SVG‑сцену (фон + здания)

- Предпосылки:
  - В `assets/images/street/` есть готовые SVG: `background.svg` (уже с деревьями), `clouds.svg`, `library.svg`, `tower.svg`, `coworking.svg`, `marketplace.svg`.
  - Требование: использовать их вместо контурного `CustomPainter` в `_StreetScene`.
- Файлы: `lib/screens/main_street_screen.dart`, (проверка) `pubspec.yaml` — раздел `assets:`.
- Что сделать:
  1) Обернуть текущий `body` в верхнеуровневый `Stack`.
  2) На самый нижний слой добавить `Positioned.fill` с `background.svg` (`BoxFit.cover`), чтобы фон тянулся до краёв экрана (сверху/снизу/по бокам) и не перекрывал верхнюю панель/нижнюю кнопку.
  3) Заменить отрисовку зданий на `SvgPicture.asset` для 4 иконок: слева — `library.svg`, центр — `tower.svg`, далее — `coworking.svg`, справа — `marketplace.svg`.
  4) Сохранить существующую вычислительную сетку `LayoutBuilder`/позиции, чтобы минимально затронуть логику.
  5) Удалить из UI подпись под башней «Этаж 1 • X/10» (не требуется по ТЗ).
- Критерии приёмки:
  - Фон всегда заполнен от края до края, независимо от платформы и ориентации.
  - 4 здания стоят на одной «линии земли», не перекрывают друг друга, кликабельны.
  - Подписи «Этаж 1 • …» под башней отсутствуют.
  - Верхняя панель (`UserInfoBar`) и нижняя кнопка «Продолжить: Уровень …» остаются на переднем плане.
  - Нет регрессий логики переходов и провайдеров.

### Задача 33.15: Анимация облаков

- Файлы: `lib/screens/main_street_screen.dart`.
- Что сделать:
  1) Добавить слой облаков поверх фона и под зданиями: `clouds.svg`.
  2) Реализовать медленное движение слева направо бесконечным циклом (`AnimationController.repeat()`), период 60–90 секунд на проход; при окончании — плавный «wrap» без рывка.
  3) Прозрачность облаков 0.85–0.9; на Web курсор/нажатия по зданиям не должны блокироваться облаками.
- Критерии приёмки:
  - Облака плавно плывут над зданиями, без подлагиваний.
  - Производительность стабильная на iOS/Android/Web (нет заметного jank).

### Задача 33.16: Ховеры/тапы и доступность

- Файлы: `lib/screens/main_street_screen.dart`.
- Что сделать:
  1) Для каждого здания обернуть SVG в `MouseRegion(cursor: click)` и `GestureDetector`/`InkWell`.
  2) Добавить `AnimatedScale` 1.0→1.05 на наведение мышью (Web/desktop) и короткое увеличение на тапе (mobile), длительность ~120 мс.
  3) Семантика: `Semantics(label: 'Библиотека/Коворкинг/Маркетплейс/Башня')`.
  4) Логика кликов остаётся прежней: башня — `/tower` или `/floor/1`, остальные — SnackBar «Скоро».
- Критерии приёмки:
  - На Web виден ховер‑эффект и курсор‑рука, на мобильных — лёгкий «поп» при тапе.
  - Зоны клика совпадают с габаритами зданий; события не «съедаются» слоем облаков.

### Задача 33.17: Адаптивность (mobile/web)

- Файлы: `lib/screens/main_street_screen.dart`.
- Что сделать:
  1) Сохранить существующую 16‑колоночную раскладку; скорректировать коэффициенты ширины/интервалов для узких экранов (<380 px), чтобы исключить наложения.
  2) Проверить пропорции `AspectRatio` сцены — 16:9; на сверхузких экранах ограничить минимальные отступы и ширины зданий.
  3) Убедиться, что нижняя кнопка не перекрывается сценой и доступна при любых брейкпоинтах.
- Критерии приёмки:
  - На мобильных нет горизонтального/вертикального overflow, тап‑зоны ≥ 48×48.
  - На Web/desktop сцена центрирована, фон покрывает всё, элементы не смещаются/не обрезаются.

### Задача 33.18: Предзагрузка/ошибки/производительность

- Файлы: `lib/screens/main_street_screen.dart`.
- Что сделать:
  1) Предзагружать `background.svg` и `clouds.svg` через `precachePicture` в `didChangeDependencies` (без жёстких await на критическом пути UI).
  2) При ошибках загрузки SVG — показывать прозрачную заглушку и логировать в Sentry (`Sentry.captureException`).
  3) Обернуть слой зданий и облаков в `RepaintBoundary`.
- Критерии приёмки:
  - Нет новых критических ошибок в Sentry, сцена рендерится стабильно.

### Задача 33.19: Тесты и наблюдаемость

- Файлы: `test/screens/street_screen_test.dart` (новый/расширенный).
- Что сделать:
  1) Проверить наличие фона (по ключу) и четырёх зданий (по ключам/семантике), отсутствие подписи «Этаж 1 • …».
  2) Проверить клик по башне → `/tower` или `/floor/1` (в зависимости от данных провайдера), клики по боковым → SnackBar «Скоро».
  3) Smoke‑проверка анимации облаков: наличие анимируемого виджета и отсутствие ошибок при тиках анимации.
- Наблюдаемость:
  - После локального прогона — получить логи Sentry за сессию через sentry‑mcp и убедиться в отсутствии RenderFlex/overflow.

### Задача 33.20: Откат текущей «сцены улицы» (SVG‑здания/облака)

- Файлы: `lib/screens/main_street_screen.dart`, `test/screens/street_screen_test.dart`.
- Что сделать:
  1) Удалить из экрана логику сцены: `_StreetScene`, `_AnimatedClouds`, `_Label`, `_HoverScaleInk` и все вызовы/позиционирование зданий/облаков.
  2) Сохранить верхнюю панель `UserInfoBar` и нижнюю кнопку «Продолжить: Уровень …» без изменений.
  3) Слой фона упростить до одного `SvgPicture.asset` с примером `assets/images/street/background.svg` (будет заменён позже): `fit: cover`, `alignment: bottomCenter`, без дополнительных смещений/трансформаций.
- Критерии приёмки:
  - Экран рендерится без облаков/зданий, верх/низ остаются.
  - Нет overflow/артефактов на Web/iOS/Android.

### Задача 33.21: Новый главный экран из 5 блоков (3 ряда)

- Файлы: `lib/screens/main_street_screen.dart` (переработка).
- Макет:
  - Фон: нижний слой `background.svg` (пример), как в 33.20.
  - Ряд 3 (верх): две кнопки — «Библиотека» (Скоро), «Маркетплейс» (Скоро).
  - Ряд 2 (середина): две кнопки — «База тренеров» (ведёт в существующую базу тренеров/чаты), «Коворкинг» (Скоро).
  - Ряд 1 (низ): одна большая кнопка «Башня БизЛевел», занимает 70% ширины нижнего ряда, по центру.
  - Верх/низ экрана: сверху `UserInfoBar`, снизу — существующая кнопка «Продолжить: Уровень …».
- Реализация:
  - `SafeArea > Column` с `Expanded` для центрального блока из 3 рядов; ширина ограничена `ConstrainedBox(maxWidth: 900)` и центрирована.
  - Универсальная карточка (InkWell + Card): параметры `title`, `icon`, `state: 'active'|'soon'`, `onTap`. Для `soon` показывать SnackBar «Скоро».
  - Доступность: `Semantics(label, button)`, min‑tap‑area ≥ 48 px.
  - Адаптивность: мобильные промежутки 12–16 px; на tablet/desktop — центрирование и ограничение ширины.
- Навигация кнопок:
  - «Башня БизЛевел» → `/tower`.
  - «База тренеров» → маршрут/вкладка текущей базы тренеров (чат).
  - «Коворкинг», «Библиотека», «Маркетплейс» → SnackBar «Скоро».
- Критерии приёмки:
  - На экране видно 5 блоков согласно макету, клики отрабатывают по описанию.
  - Верх/низ экрана без регрессий.

### Задача 33.22: Тесты для нового главного экрана

- Файлы: `test/screens/street_screen_test.dart` (обновить).
- Что проверить:
  1) Рендер 5 карточек с правильными подписями.
  2) Клик по «Базе тренеров» ведёт на ожидаемый маршрут/вкладку; клик по «Башне» ведёт на `/tower`.
  3) Клик по «Скоро» показывает SnackBar.
  4) Отсутствие RenderFlex/overflow на типовых размерах.
- Критерии приёмки: тесты проходят локально и в CI.

### Задача 33.23: Наблюдаемость и устойчивость

- Что сделать:
  - Все переходы обернуть в try/catch с `Sentry.captureException` и дружелюбным SnackBar при ошибке навигации.
  - После локальных прогона/тестов — получить последние события через sentry‑mcp и убедиться, что нет новых критичных ошибок UI (overflow, layout, render).
- Критерии приёмки: в Sentry нет новых критичных ошибок после навигации по 5 кнопкам.
### Задача 33.24: Чистка и активы (после стабилизации)
- Файлы: `assets/images/street/` и `lib/screens/main_street_screen.dart`.
- Что сделать:
  - Если SVG зданий (`library.svg`, `coworking.svg`, `marketplace.svg`, `tower.svg`, `clouds.svg`) нигде больше не используются — вынести в архив или удалить отдельным MR.
  - Оставить только `background.svg` как пример (будет заменён позже на финальный фон).
- Критерии приёмки: нет неиспользуемых импортов/ассетов, `flutter analyze` чистый.
### Задача 33.25: Финальный фон
- Что сделать:
  - Заменить временный `background.svg` на финальный файл (когда будет готов), сохранить `fit: cover`, `alignment: bottomCenter`.
  - Добавить `precachePicture` для фона в `didChangeDependencies` ради плавной отрисовки.
- Критерии приёмки: фон подменяется без мерцаний и регрессий макета.
