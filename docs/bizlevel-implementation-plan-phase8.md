# Этап 30: Правки по UX/UI

### Задача 30.1: Уровень 0 — форма профиля в режиме «просмотр/редактирование»
- Цель: после сохранения профиля («Перейти на Уровень 1») поля остаются заполненными и переходят в read-only. В правом верхнем углу блока появляется серая иконка «Редактировать», по нажатию поля становятся активными.
- Файлы: `lib/screens/level_detail_screen.dart` (+минимальные правки в `CustomTextBox`, если потребуется только проп `readOnly`).
- Что сделать:
  1) Поднять состояние формы в `_LevelDetailScreenState`: контроллеры `profileNameCtrl/profileAboutCtrl/profileGoalCtrl`, `selectedAvatarId`, флаг `isProfileEditing` (по умолчанию `true` до первого сохранения), `profileInitialized`.
  2) При первом получении данных `currentUserProvider` заполнить контроллеры и `selectedAvatarId`, затем `profileInitialized = true`.
  3) Передать контроллеры/`selectedAvatarId`/`isProfileEditing` в `_ProfileFormBlock` через конструктор; внутри блока убрать создание собственных контроллеров.
  4) В UI формы использовать `CustomTextBox(readOnly: !isProfileEditing)` и добавить `IconButton(Icons.edit, color: Colors.grey)` в правом верхнем углу блока. По нажатию переключать `isProfileEditing = true`.
  5) После успешного `AuthService.updateProfile(...)` ставить `isProfileEditing = false` и `_profileSaved = true` (для логики «Завершить уровень»). Значения в полях остаются от контроллеров — повторный заход отображает их сразу.
- Критерии приёмки:
  - После нажатия «Перейти на Уровень 1» при повторном открытии уровня 0 поля предзаполнены из профиля и заблокированы для редактирования.
  - Иконка «Редактировать» присутствует; после нажатия поля становятся активными, повторное сохранение обновляет профиль.
  - Никаких изменений схемы БД; используются существующие `updateProfile` и провайдеры.

### Задача 30.2: Страница «Цель» — read-only после сохранения + иконка «Редактировать»
- Цель: по умолчанию существующая последняя версия цели отображается в режиме просмотра; поля становятся редактируемыми только по нажатию на серую иконку «Редактировать». Автосохранение отключено в режиме просмотра.
- Файлы: `lib/screens/goal_screen.dart`.
- Что сделать:
  1) Добавить флаг `_isEditing`. Инициализация: если версия отсутствует — `_isEditing = true`; если версия существует — `_isEditing = false` (только последняя версия доступна для редактирования).
  2) При переключении версии устанавливать `_isEditing = (выбранная версия == последняя)`.
  3) Во все `CustomTextBox` передать `readOnly: !_isEditing`. Кнопку «Сохранить» блокировать, если `_isEditing == false`.
  4) В заголовке «Кристаллизация цели vX» добавить `IconButton(Icons.edit, color: Colors.grey)`; клик переводит `_isEditing = true` (только для последней версии).
  5) В `_scheduleAutosave()` мгновенно выходить, если `_isEditing == false`.
  6) После успешного `_saveGoal()` — `_isEditing = false`, значения остаются в контроллерах.
- Критерии приёмки:
  - При наличии сохранённой v1 (или выше) форма открывается в read-only, автосохранение не срабатывает; отображается иконка «Редактировать».
  - Нажатие иконки включает редактирование только для последней версии; после «Сохранить» форма снова read-only с актуальными значениями.
  - Поведение версий (создание следующей) не изменено. БД/репозитории остаются прежними (`core_goals`, `GoalsRepository`).

### Задача 30.3: Переименование бота «Алекс» → «Макс» (БД + Edge + клиент)
- Цель: унифицировать имя бота‑трекера везде как «Макс»/`max`.
- Файлы/инструменты: `supabase/functions/leo-chat/index.ts`, `lib/services/leo_service.dart`, `lib/screens/goal_screen.dart`, `lib/screens/leo_chat_screen.dart`, `lib/widgets/floating_chat_bubble.dart`, `lib/screens/leo_dialog_screen.dart`, supabase‑mcp (миграция).
- Что сделать:
  1) БД (через supabase‑mcp `apply_migration`):
     - `UPDATE public.leo_chats SET bot = 'max' WHERE bot = 'alex';`
     - Переопределить CHECK на колонке `leo_chats.bot` → `CHECK (bot in ('leo','max'))`.
  2) Edge Function `leo-chat`: трактовать `bot` как строку `'leo' | 'max'`; временно поддержать входящий `'alex'` как `'max'` для совместимости. Тексты промпта обновить: «Ты — Макс…».
  3) Клиент: заменить все сравнения/передачи `'alex'` → `'max'`; русские подписи «Алекс» → «Макс». В `GoalScreen` для bubble `bot: 'max'`.
- Критерии приёмки:
  - Список чатов фильтруется по `bot='leo'/'max'`, старые записи с `'alex'` видны как `'max'`.
  - Отправка сообщений с `bot='max'` работает; edge‑функция возвращает ответы без регрессий.

### Задача 30.4: Страница «Чат» — выбор бота карточками
- Цель: заменить чипы «Лео/Макс» на две большие кнопки‑карточки по центру экрана.
- Файлы: `lib/screens/leo_chat_screen.dart`, ассеты `assets/images/avatars/avatar_leo.png`, `assets/images/avatars/avatar_max.png` (уже есть).
- Что сделать:
  1) В шапке оставить счётчик сообщений для активного бота, убрать текущий заголовок аватар и имя бота
  2) Вместо `_buildBotSwitcher()` отрисовать две карточки одинакового размера:
     - Лео: аватар, «Лео AI», подпись серым «Твой бизнес‑ментор».
     - Макс: аватар `avatar_max.png`, «Макс AI», подпись серым «Твой помощник в достижении цели».
     - Активную карточку подсвечивать (обводка/фон), по нажатию — переключать `_activeBot` и перезагружать список.
- Критерии приёмки: карточки по центру, корректная подсветка активного, фильтрация чатов работает.

### Задача 30.5: FAB/баббл — «Новый чат с …» + мини‑ава
- Файлы: `lib/screens/leo_chat_screen.dart`, `lib/widgets/floating_chat_bubble.dart`.
- Что сделать:
  1) В тексте заменить «Новый диалог с …»/«Обсудить с …» → «Новый чат с Лео/Максом».
  2) Вставить слева маленький `CircleAvatar` бота (соответствующий аватар).
- Критерии приёмки: корректные подписи и аватары для обоих ботов.

### Задача 30.6: Шапка окна диалога — аватар + имя на кириллице
- Файлы: `lib/screens/leo_dialog_screen.dart`.
- Что сделать: в `AppBar.title` вместо текста «Диалог с …» отрисовать Row: аватар бота + имя «Лео»/«Макс» (кириллица), выровнять по центру, сохранить цветовую схему.
- Критерии приёмки: правильные имена/аватары по типу бота, без переломов макета на мобильном и web.

# Этап 31: Замена тестов на чат

### Задача 31.1: Анализ и подготовка данных квиза
- Цель: убедиться, что текущие данные уроков подходят для «чат‑теста» без миграций схемы.
- Что сделать:
  1) Проверить, что у всех уроков, где есть квиз, в `lessons.quiz_questions[0]` присутствуют поля `question: string`, `options: string[]` и есть соответствующий `correct_answers[0]: int`.
  2) (Опционально) Для каждого такого квиза добавить поле `script` в JSON `quiz_questions[0]` — короткая установка от имени Лео (если поле отсутствует, клиент покажет дефолтное приветствие).
- База данных: миграции не требуются; работаем с существующей структурой `lessons`.

### Задача 31.2: Клиент — новый виджет `LeoQuizWidget`
- Файлы: `lib/widgets/leo_quiz_widget.dart` (новый), `lib/screens/level_detail_screen.dart` (использование в блоке квиза).
- Что сделать:
  1) Создать виджет `LeoQuizWidget` с пропсами: `questionData`, `onCorrect`, `initiallyPassed`, `userContext`.
  2) UI: первое сообщение ассистента (из `questionData.script` или дефолт), список вариантов ответа кнопками под зоной ввода, компактная лента сообщений (1–2 сообщения), без истории.
  3) Поведение: локально проверять выбор (`selectedIndex == correctIndex`), запрашивать короткий ответ от Лео (успех/подсказка), при верном ответе — дизейблить варианты и вызывать `onCorrect(pageIndex)` для разблокировки «Далее».
  4) Поддержать `initiallyPassed: true` — сразу показывать состояние «пройдено», без возможности повторного ввода.
  5) Обработка ошибок/оффлайн: при недоступности Edge отобразить локальную заготовку ответа; «Далее» разрешать после локальной валидации верного варианта (поведение задать как дефолтное, чтобы не блокировать прогресс оффлайн).

### Задача 31.3: Клиент — сервис `LeoService.sendQuizFeedback`
- Файл: `lib/services/leo_service.dart`.
- Что сделать:
  1) Добавить метод `Future<Map<String, dynamic>> sendQuizFeedback({ required String question, required List<String> options, required int selectedIndex, required int correctIndex, required String userContext, int maxTokens = 180 })`.
  2) Вызов: POST `/leo-chat` с телом `{ mode: 'quiz', isCorrect, quiz: { question, options, selectedIndex, correctIndex }, userContext, maxTokens }`.
  3) В режиме `quiz` не выполнять `decrementMessageCount()` и не вызывать `saveConversation()` — эти сообщения не должны расходовать общий лимит и не должны создавать записи в `leo_chats/leo_messages`.
  4) Таймауты/ретраи — как в существующих методах; маппинг ошибок в `LeoFailure` и отдельное сообщение для оффлайн.
  5) Наблюдаемость: оборачивать ошибки в Sentry (`captureException`) без PII.

### Задача 31.4: Edge Function `leo-chat` — режим `mode='quiz'`
- Файл: `supabase/functions/leo-chat/index.ts`. Инструменты: supabase‑mcp для деплоя.
- Что сделать:
  1) Принимать payload с `mode: 'quiz'`, `isCorrect: boolean`, `quiz: { question, options, selectedIndex, correctIndex }`, `userContext: string`, `maxTokens?: number`.
  2) Для `mode='quiz'` отключить RAG/память/историю и любые записи в БД; ответ строить как одно короткое сообщение ассистента. Уважать `maxTokens` (по умолчанию 160–200), температуру снизить.
  3) Системный промпт на русском: краткий, без «чем ещё помочь». Ветвление по `isCorrect`: 
     - неверно — поддержка и мягкая подсказка, не раскрывая правильный вариант;
     - верно — короткое поздравление и 2–3 строки персональной применимости на основе `userContext` (`users.name/goal/about`).
  4) Логирование: структурированное, без PII.
  5) Совместимость: текущие ветки Лео/Макс без изменений; `mode='quiz'` — отдельная ветка ответа, не влияющая на обычный чат.

### Задача 31.5: Интеграция в маршрут уровня
- Файл: `lib/screens/level_detail_screen.dart`.
- Что сделать:
  1) Внутри `_QuizBlock` заменить `QuizWidget` на `LeoQuizWidget`, сохранив логику `onCorrect(index)` и `initiallyPassed`.
  2) Передавать `userContext`, собранный из `currentUserProvider` (минимум: имя, цель, о себе) в компактной строке.
  3) Никаких изменений в `_isLevelCompleted()` и прогрессе не требуется: `onCorrect(index)` по‑прежнему вызывает `markQuizPassed(index)` и `unlockNext(index)`.

### Задача 31.6: Фича‑флаг и обратная совместимость
- Файлы: `lib/screens/level_detail_screen.dart`, (опц.) `lib/utils/constant.dart`.
- Что сделать:
  1) Ввести флаг `kUseLeoQuiz` (compile‑time или константа), включающий новый виджет `LeoQuizWidget`.
  2) При `kUseLeoQuiz == false` рендерить старый `QuizWidget` — безопасное поэтапное включение.

### Задача 31.7: Тесты
- Файлы: `test/level_detail_screen_test.dart`, `test/services/leo_service_test.dart`, `test/widgets/leo_quiz_widget_test.dart`, `test/web_smoke_test.dart` (добавление сценария).
- Что проверить:
  1) Разблокировка «Далее» после верного ответа в `LeoQuizWidget` и вызова `onCorrect`.
  2) `LeoService.sendQuizFeedback` — корректный payload, заголовки, обработка сетевых ошибок.
  3) Оффлайн‑сценарий: локальное поздравление и возможность продолжить.
  4) Web‑рендер `LeoQuizWidget` с мок‑сервисом — отсутствие ошибок.

### Задача 31.8: Наблюдаемость и безопасность
- Файлы: `lib/services/leo_service.dart`, `supabase/functions/leo-chat/index.ts`.
- Что сделать:
  1) Логировать ошибки в Sentry на клиенте (без PII), в Edge — структурированные логи (без пользовательских данных).
  2) Убедиться, что режим `quiz` не изменяет лимиты сообщений пользователя и не создаёт записи в `leo_chats/leo_messages`.
  
### Задача 31.9: Миграция вопросов/вариантов/комментариев из `docs/archive/Вопросы для тестов.md` в Supabase
- Цель: перенести подготовленные вопросы (уровни 1–10, блоки 1–4) в БД, чтобы «чат‑тест» использовал реальные данные.
- Таблицы/схема: без изменений. Используем существующие поля в `public.lessons`:
  - `quiz_questions jsonb[]` — кладём один объект c ключами: `{ question, options, correct, script?, explanation? }`;
  - `correct_answers int[]` — массив из одного индекса `correct`.
- Маппинг:
  1) Соотнести разделы markdown по заголовкам «Уровень N» с записями `levels.number = N`.
  2) Внутри уровня привязать «Блок 1..4» к `lessons(order = 1..4)` по возрастанию `order`.
  3) Если количество уроков ≠ количеству блоков:
     - уроков больше — заполняем первые K блоков, остальные квизы оставляем пустыми;
     - уроков меньше — используем первые K блоков из markdown, остальные пропускаем (внести в TODO на дополнение уроков/контента).
  4) `options` — список вариантов (A..D) в порядке; `correct` — индекс правильного варианта (0..3) по букве; `explanation` — абзац после «Правильный ответ»; `script` — короткое вступление Лео (если нет в md — сгенерировать дефолт «Давай проверим понимание…»).
- Реализация:
  1) Написать одноразовый конвертер `scripts/quiz_md_to_json.py` (или `.dart`): парсинг md → JSON‑карта `{ level, block, question, options[], correctLetter, explanation }`.
  2) Генерировать SQL‑файл с `UPDATE public.lessons SET quiz_questions = '[{...}]'::jsonb[], correct_answers = ARRAY[<idx>] WHERE level_id = <id> AND "order" = <block>;` для каждого урока.
  3) Запустить SQL через supabase‑mcp (`execute_sql`) батчами по уровню.
- Проверка/валидация:
  1) Выборки: `select level_id, "order", quiz_questions, correct_answers from public.lessons where level_id in (select id from levels where number between 1 and 10) order by level_id, "order";`
  2) Ручной просмотр 2–3 уровней в клиенте: отображается вступительное сообщение, варианты присутствуют, верный индекс работает.
  3) Локальный тест «прогресс» — `onCorrect` срабатывает, «Далее» активна.
- Критерии приёмки:
  - Во всех уровнях 1–10 у соответствующих уроков заполнены `quiz_questions[0]` и `correct_answers[0]`.
  - Объяснение (`explanation`) доступно для Edge‑ответа (персонализированный совет после правильного ответа может учитывать эту подсказку).
  - Никаких DDL/изменений схемы; только UPDATE существующих записей `lessons`.


### Задача 31.10: Критерии приёмки
- После просмотра видео появляется блок «чат‑тест» вместо старого квиза.
- Неверный ответ — поддержка и предложение попробовать ещё раз; «Далее» неактивна.
- Верный ответ — короткое поздравление + персональная применимость; блок фиксируется как пройденный, «Далее» активна.
- Прогресс уровня и завершение работают без изменений; БД‑миграции не нужны.
- Режим `quiz` не создаёт чатов и не тратит лимит сообщений.
- Оффлайн или сбой Edge — показать локальный ответ и разрешить «Далее» после верной локальной проверки.
- Перерасход токенов — жёсткий `maxTokens` и лаконичный системный промпт.
- Регрессии UI — фича‑флаг и поэтапное включение; fallback на `QuizWidget`.

### Задача 31.11: LeoQuizWidget — чат‑оформление (хедер и лента сообщений)
- Цель: визуально сделать блок квиза как открытый чат с Лео — сверху аватар и имя «Лео», справа бейдж «Вопрос X.Y», ниже лента сообщений (сообщения Лео).
- Файлы: `lib/widgets/leo_quiz_widget.dart`, `lib/screens/level_detail_screen.dart`, ассеты `assets/images/avatars/avatar_leo.png` (уже есть).
- Что сделать:
  1) В `LeoQuizWidget` добавить параметры `levelNumber` и `questionIndex`.
  2) В `_QuizBlock` пробросить `levelNumber: widget.levelNumber ?? widget.levelId`, `questionIndex: lesson.order`.
  3) Сверху отрисовать хедер: `CircleAvatar(avatar_leo.png)` + текст «Лео»; справа — `Chip` «Вопрос {levelNumber}.{questionIndex}» с фоном `AppColor.primary.withOpacity(0.1)` и текстом `AppColor.primary`.
  4) В зоне контента заменить статические контейнеры на ленту сообщений с использованием `LeoMessageBubble`:
     - первое сообщение Лео — `script` (если отсутствует — дефолтная фраза);
     - второе сообщение Лео — сам текст вопроса.
  5) Поддержать `initiallyPassed`: карточки выбора отключены, под вопросом короткое сообщение Лео «Тест уже пройден ✅» (или `explanation`, если есть).
- Критерии приёмки:
  - Хедер и лента выглядят как в реальном диалоге; шрифты/отступы согласованы с существующим экраном чата.
  - Логика прогресса, сетевые вызовы и фича‑флаг не меняются.

### Задача 31.12: Выбор ответов карточками + отличающийся цвет (без путающих «кнопок»)
- Цель: варианты ответа показывать как кликабельные карточки (не Radio/кнопки) с нейтральной подсветкой, чтобы визуально отличались от навигационных кнопок «Назад/Обсудить/Далее» и при этом сохраняли логику переписки.
- Файлы: `lib/widgets/leo_quiz_widget.dart`.
- Что сделать:
  1) Заменить `RadioListTile` на список карточек‑вариантов:
     - базовый стиль: `Container` с закруглением 12, тонкая рамка `Colors.grey.shade300`, фон `Colors.white`;
     - при выборе: фон `Colors.blue.shade50`, рамка `AppColor.primary`, иконка галочки справа.
  2) При тапе по карточке:
     - мгновенно добавить в ленту пользовательский бабл (`LeoMessageBubble(isUser: true)`) с текстом выбранного варианта;
     - запустить существующую проверку (`_sendAssistantReply`); на время ответа заблокировать выбор других вариантов;
     - кнопку «Проверить» скрыть (не используется).
  3) По завершении проверки добавить бабл Лео с результатом (`_assistantMessage`); при верном ответе вызывать `onCorrect()` (как сейчас).
  4) Цветовое различие: карточки вариантов используют нейтральную палитру (белый фон + серая рамка, активное состояние — светло‑голубой фон), чтобы не конфликтовать визуально с основными кнопками экрана. Пользовательский бабл остаётся фирменного цвета `AppColor.primary`.
- Критерии приёмки:
  - Варианты визуально отличаются от навигационных кнопок; UX однозначно воспринимается как «диалог + варианты».
  - Выбор запускает проверку без дополнительной кнопки; оффлайн‑фолбэк работает как прежде.


# Этап 32: Дизайн и UX
 
### Задача 32.1: Глобальная компоновка страницы «Цель» (каркас и ритм)
- Цель: сделать страницу легче для сканирования на web/mobile за счёт ограничителя ширины, единого каркасного стиля карточек и ровного вертикального ритма. Логику и провайдеры не менять.
- Файлы: `lib/screens/goal_screen.dart` (основной), (опц.) `lib/theme/color.dart` (добавить мягкие нейтрали/градиент при необходимости, без BC‑лома).
- Что сделать:
  1) Обернуть контент `GoalScreen` в `Center` + `ConstrainedBox(maxWidth: 840)` для web/desktop; на мобильном поведение без изменений.
  2) Привести секции к единому каркасу (существующий контейнер с белым фоном/тенью): мотивация, версии, форма версии, «Путь к цели» — одинаковые отступы 16–24 px.
  3) В верхнем заголовке: «Цель» + серый подзаголовок «Сформулируйте цель и пройдите 4 версии». Справа небольшой статус‑чип «Версия X из 4» и «Доступно до vY» (на основе текущего уровня).
  4) Заменить подпись «Автосохранение каждые 200 мс» на чип режима: «Режим: Просмотр/Редактирование» (цвет нейтральный/первичный). Автосохранение не включать.
- Критерии приёмки:
  - На экранах ≥1024 px ширина контента визуально ограничена (≤ 840 px), без горизонтальных переполнений.
  - Все секции выглядят консистентно: одинаковая тень, скругление, внутренние отступы; вертикальные интервалы ровные.
  - Текст про автосохранение исчез, отображается чип режима.

### Задача 32.2: Навигация версий (v1–v4) со статусами
- Цель: повысить понятность и мотивацию при переключении версий, сохранив текущую логику гейтинга.
- Файлы: `lib/screens/goal_screen.dart`.
- Что сделать:
  1) Обновить лейблы: `v1 Семя`, `v2 Метрики`, `v3 SMART`, `v4 Финал` (русские подписи).
  2) Показать статусы: текущая — подсветка; завершённые — чек ✓; недоступные — иконка замка и `tooltip` «Откроется после Уровня N».
  3) Не менять условия доступности/создания следующей версии — только визуальная индикация.
- Критерии приёмки:
  - Пользователь видит понятные подписи и статусы версий; при ховере/табе на заблокированную показывает подсказку.
  - Переключение и гейтинг работают как прежде; сохранение форм не изменилось.

### Задача 32.3: Формы v1–v4 — читаемость и дружелюбные подсказки
- Цель: улучшить сканируемость и снизить когнитивную нагрузку в формах версий без изменения полей/валидаций.
- Файлы: `lib/screens/goal_screen.dart` (только вёрстка и тексты).
- Что сделать:
  1) Сгруппировать поля по смыслу под мини‑подзаголовками («Почему сейчас», «Препятствие», «Метрика»). Реализовать разметкой внутри файла, без выноса новых публичных виджетов.
  2) Уточнить `hint`‑тексты (1 строка, тёплый тон, пример). Поля чисел (v2) по возможности настроить на числовую клавиатуру (если `CustomTextBox` поддерживает `keyboardType`).
  3) В v4 переключатель «Готов к реализации» оформить как `Switch` с подписью справа; поведение `_commitment` оставить прежним.
  4) Кнопки: primary «Сохранить», справа чип «Просмотр/Редактирование»; иконка «Редактировать» остаётся в заголовке блока.
- Критерии приёмки:
  - Поля логически сгруппированы; подсказки понятные, без длинных текстов.
  - На мобильном числовые поля открывают цифровую клавиатуру (где поддерживается компонентом).
  - После «Сохранить» режим возвращается в «Просмотр» (как сейчас); логика валидаций/запросов не менялась.

### Задача 32.4: «Путь к цели» — визуальный прогресс спринта
- Цель: сделать блок спринтов наглядным (7 дней, текущий спринт), не меняя текущих данных и API.
- Файлы: `lib/screens/goal_screen.dart`.
- Что сделать:
  1) Заголовок: «Путь к цели • Спринт S» + лёгкая плашка «7 дней».
  2) Мини‑timeline из 7 точек (вертикально/горизонтально в зависимости от ширины) с подписями «День n»; текущий день можно отображать нейтрально (без вычислений по дате, чтобы не трогать логику).
  3) Форму чек‑ина визуально облегчить: на desktop — две колонки, на mobile — одна; «Проверки недели» (чипы) сгруппировать в отдельный подпункт.
  4) После сохранения чек‑ина показать вторичную кнопку‑CTA «Обсудить с Максом» (выполняет то же действие, что нажатие плавающего баббла).
- Критерии приёмки:
  - Есть 7‑точечная шкала дней спринта; верстка не ломается на web/mobile.
  - При сохранении чек‑ина отображается CTA к чату; существующая логика сохранения не меняется.

### Задача 32.5: Блок «Мотивация» — аватар Макса, градиент, скелетон
- Цель: сделать мотивационный блок вдохновляющим и компактным, с аккуратной загрузкой/ошибками.
- Файлы: `lib/screens/goal_screen.dart` (вёрстка), ассеты уже есть (`assets/images/avatars/avatar_*.png`).
- Что сделать:
  1) Левая колонка: `CircleAvatar(Max)`; правая — цитата (2–3 строки) + автор; фон — мягкий градиент/подсветка из темы.
  2) В состоянии загрузки — скелетон (серые плашки); при ошибке — дружелюбный текст «Сегодня работаем по плану — без цитаты».
- Критерии приёмки:
  - Визуально блок с аватаром и аккуратным фоном; загрузка и ошибка выглядят ненавязчиво.
  - Длина цитаты не приводит к переполнению/обрезке на мобильном.

### Задача 32.6: Доступность, состояния и типографика
- Цель: унифицировать доступность (минимальные размеры интерактивов), пустые/ошибочные состояния и типографику desktop.
- Файлы: `lib/screens/goal_screen.dart`, (опц.) `lib/theme/color.dart`.
- Что сделать:
  1) Минимальная высота кликабельных элементов ≥ 44 px; увеличить `title` на desktop на +1 pt.
  2) Пустые состояния: «Путь к цели доступен после v4», «Цитата недоступна» — с иконкой и коротким дружелюбным текстом.
  3) Локализация/копирайтинг: выровнять терминологию («цель», «спринт», «версия») и тон сообщений.
- Критерии приёмки:
  - Интерактивы соответствуют минимальным размерам; тексты унифицированы, переполнений нет.
  - Нет новых предупреждений анализатора/линутера, существующие тесты не ломаются.

### Задача 32.7: Наблюдаемость и регресс‑чек
- Цель: убедиться, что визуальные правки не вносят регрессии и не создают UI‑исключений.
- Файлы/инструменты: `lib/screens/goal_screen.dart`; sentry‑mcp (чтение логов за последние 24 ч), локальные тесты.
- Что сделать:
  1) Прогнать `flutter analyze` и существующие тесты (`flutter test`).
  2) Через sentry‑mcp убедиться в отсутствии свежих RenderFlex overflow/Layout ошибок, связанных с `GoalScreen`.
  3) На web проверить ширину контейнера и отсутствие горизонтального скролла.
- Критерии приёмки:
  - Sentry не показывает новые критические UI‑ошибки, тесты и анализ проходят.
  - Визуальные изменения соответствуют макету из задач 32.1–32.6, логика данных/запросов неизменна.